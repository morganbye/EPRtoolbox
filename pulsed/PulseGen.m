function varargout = PulseGen(varargin)

% PULSEGEN A graphical user interface for the generation of Electron
%       Paramagnetic Resonance (EPR) pulse sequence figures.
%
% PULSEGEN's initial idea and command line script coding was written by Dr. Frederic Mentink (Weizmann,
% IL) the user interface was generated by Dr. Morgan Bye.
%
% Syntax:  PULSEGEN
%
% Inputs:
%    input1 - n/a
%
% Outputs:
%    output1 - n/a
%
% Example: 
%    see http://morganbye.net/PulseGen
%
% Other m-files required:
%    none
%
% Subfunctions:
%    none
%
% MAT-files required: none
%
% See also: 

%                                        _                             _   
%                                       | |                           | |  
%  _ __ ___   ___  _ __ __ _  __ _ _ __ | |__  _   _  ___   _ __   ___| |_ 
% | '_ ` _ \ / _ \| '__/ _` |/ _` | '_ \| '_ \| | | |/ _ \ | '_ \ / _ \ __|
% | | | | | | (_) | | | (_| | (_| | | | | |_) | |_| |  __/_| | | |  __/ |_ 
% |_| |_| |_|\___/|_|  \__, |\__,_|_| |_|_.__/ \__, |\___(_)_| |_|\___|\__|
%                       __/ |                   __/ |                      
%                      |___/                   |___/                       
%
% M. Bye v13.12
%
% v13.09 - current
%               Chemical Physics Department
%               Weizmann Institute of Science
%               76100 REHOVOT, Israel
%
% Email:        morgan.bye@weizmann.ac.il
% Website:      http://morganbye.net/eprtoolbox
%
% Last updated  10-December-2013

% Edit the above text to modify the response to help PulseGen

% Last Modified by GUIDE v2.5 10-Dec-2013 17:38:49

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @PulseGen_OpeningFcn, ...
                   'gui_OutputFcn',  @PulseGen_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before PulseGen is made visible.
function PulseGen_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to PulseGen (see VARARGIN)

% Choose default command line output for PulseGen
handles.output = hObject;

% Name the window
set(gcf,'Name','PulseGen - v13.12')

% Clear the axes
axes(handles.axes_pulses);
% axis off;
set(gca, 'YTick', []);
xlabel('Time / ns');

% Set up the tables
set(handles.tbl_pulses,'Data', {'1' '16' '10' '100';...
                                '1' '32' '10' '200'});
                            
set(handles.tbl_delays,'Data', {'1' '10'});
                            
set(handles.tbl_echoes,'Data', {'32' '10' '1'});

PulseGenPlot(hObject, eventdata, handles);

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes PulseGen wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = PulseGen_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes during object creation, after setting all properties.
function figure1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to figure1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called



%   _______    _     _           
%  |__   __|  | |   | |          
%     | | __ _| |__ | | ___  ___ 
%     | |/ _` | '_ \| |/ _ \/ __|
%     | | (_| | |_) | |  __/\__ \
%     |_|\__,_|_.__/|_|\___||___/
%                                
%                                

% --- Executes on button press in button_tbl_pulses_add.
function button_tbl_pulses_add_Callback(hObject, eventdata, handles)
% hObject    handle to button_tbl_pulses_add (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

tbl_pulses_value = get(handles.tbl_pulses,'Data');
set(handles.tbl_pulses,'Data',...
    [tbl_pulses_value;{'1' '0' '0' '0'}]);

% --- Executes on button press in button_tbl_pulses_rm.
function button_tbl_pulses_rm_Callback(hObject, eventdata, handles)
% hObject    handle to button_tbl_pulses_rm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
a = get(handles.tbl_pulses,'Data');
tbl_pulses_value = a(1:(size(a,1)-1),:);
set(handles.tbl_pulses,'Data',tbl_pulses_value);

% --- Executes on button press in pushbutton_pulses_help.
function pushbutton_pulses_help_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton_pulses_help (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

helpdlg('This table contains all of the pulse information. The channel column dictates which channel the pulse appears in. The delay column dictates the time after this pulse before the next pulse.'...
    ,'PulseGen: Pulses table help');

% --- Executes when entered data in editable cell(s) in tbl_pulses.
function tbl_pulses_CellEditCallback(hObject, eventdata, handles)
% hObject    handle to tbl_pulses (see GCBO)
% eventdata  structure with the following fields (see UITABLE)
%	Indices: row and column indices of the cell(s) edited
%	PreviousData: previous data for the cell(s) edited
%	EditData: string(s) entered by the user
%	NewData: EditData or its converted form set on the Data property. Empty if Data was not changed
%	Error: error string when failed to convert EditData to appropriate value for Data
% handles    structure with handles and user data (see GUIDATA)

PulseGenPlot(hObject, eventdata, handles);

% --- Executes on button press in pushbutton_delays_add.
function pushbutton_delays_add_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton_delays_add (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

tbl_delays_value = get(handles.tbl_delays,'Data');
set(handles.tbl_delays,'Data',...
    [tbl_delays_value;{'1' '0' '0' '0'}]);

% --- Executes on button press in pushbutton_delays_rm.
function pushbutton_delays_rm_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton_delays_rm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

a = get(handles.tbl_delays,'Data');
tbl_pulses_value = a(1:(size(a,1)-1),:);
set(handles.tbl_delays,'Data',tbl_pulses_value);

% --- Executes on button press in pushbutton_delays_help.
function pushbutton_delays_help_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton_delays_help (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% --- Executes when entered data in editable cell(s) in tbl_delays.

helpdlg('This table contains the delay information for each channel before the first pulse appears'...
    ,'PulseGen: Delays table help');

function tbl_delays_CellEditCallback(hObject, eventdata, handles)
% hObject    handle to tbl_delays (see GCBO)
% eventdata  structure with the following fields (see UITABLE)
%	Indices: row and column indices of the cell(s) edited
%	PreviousData: previous data for the cell(s) edited
%	EditData: string(s) entered by the user
%	NewData: EditData or its converted form set on the Data property. Empty if Data was not changed
%	Error: error string when failed to convert EditData to appropriate value for Data
% handles    structure with handles and user data (see GUIDATA)

PulseGenPlot(hObject, eventdata, handles);

% --- Executes on button press in button_tbl_pulses_add.
function button_tbl_echoes_add_Callback(hObject, eventdata, handles)
% hObject    handle to button_tbl_pulses_add (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
tbl_echoes_value = get(handles.tbl_echoes,'Data');
set(handles.tbl_echoes,'Data',...
    [tbl_echoes_value;{'1' '0' '0'}]);

% --- Executes on button press in button_tbl_echoes_rm.
function button_tbl_echoes_rm_Callback(hObject, eventdata, handles)
% hObject    handle to button_tbl_echoes_rm (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
a = get(handles.tbl_echoes,'Data');
tbl_echoes_value = a(1:(size(a,1)-1),:);
set(handles.tbl_echoes,'Data',tbl_echoes_value);

% --- Executes on button press in pushbutton_echo_help.
function pushbutton_echo_help_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton_echo_help (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

helpdlg('This table contains the detection echo parameters - it will always appear in channel 1'...
    ,'PulseGen: Echoes table help');

% --- Executes when entered data in editable cell(s) in tbl_echoes.
function tbl_echoes_CellEditCallback(hObject, eventdata, handles)
% hObject    handle to tbl_echoes (see GCBO)
% eventdata  structure with the following fields (see UITABLE)
%	Indices: row and column indices of the cell(s) edited
%	PreviousData: previous data for the cell(s) edited
%	EditData: string(s) entered by the user
%	NewData: EditData or its converted form set on the Data property. Empty if Data was not changed
%	Error: error string when failed to convert EditData to appropriate value for Data
% handles    structure with handles and user data (see GUIDATA)

PulseGenPlot(hObject, eventdata, handles);


%   __  __                  
%  |  \/  |                 
%  | \  / | ___ _ __  _   _ 
%  | |\/| |/ _ \ '_ \| | | |
%  | |  | |  __/ | | | |_| |
%  |_|  |_|\___|_| |_|\__,_|
%  

% --------------------------------------------------------------------
function menu_file_Callback(hObject, eventdata, handles)
% hObject    handle to menu_file (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function menu_file_open_Callback(hObject, eventdata, handles)
% hObject    handle to menu_file_open (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function menu_file_save_Callback(hObject, eventdata, handles)
% hObject    handle to menu_file_save (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function menu_file_export_Callback(hObject, eventdata, handles)
% hObject    handle to menu_file_export (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% stores savepath for the phase plot
[filename, pathname] = uiputfile({ '*.eps','Encapsulated Postscript (*.eps)';...
        '*.png','Portable Network Graphic (*.png)';...
        '*.bmp','Bitmap (*.bmp)'; '*.fig','Figure (*.fig)'}, ... 
        'Save picture as','default');

% if user cancels save, nothing happens
if isequal(filename,0) || isequal(pathname,0)
    return
end

% Set axes to copy
axesObject = gca;

% create a new figure
newFig = figure;

% get the units and position of the axes object
%axes_units = get(axesObject,'Units');
% axes_pos = get(axesObject,'Position');

% copies axesObject onto new figure
axesObject2 = copyobj(axesObject,newFig);

% realign the axes object on the new figure
% set(axesObject2,'Units',);
% set(axesObject2,'Position',[15 5 axes_pos(3) axes_pos(4)]);

% adjusts the new figure accordingly
set(newFig,'Units','normalized');
set(gca,'Position',[0.1 0.1 0.8 0.8]);

% Tidy it up
set(gcf,'color', 'white');

% Save the plot
saveas(newFig,[pathname filename]) 

% Closes the figure
close(newFig)

% --------------------------------------------------------------------
function menu_file_clear_Callback(hObject, eventdata, handles)
% hObject    handle to menu_file_clear (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

set(handles.tbl_pulses,'Data', {'1' '0' '0' '0'});

set(handles.tbl_delays,'Data', {'1' '10'});

set(handles.tbl_echoes,'Data',...
    [tbl_echoes_value;{'1' '0' '0'}]);


% --------------------------------------------------------------------
function menu_file_close_Callback(hObject, eventdata, handles)
% hObject    handle to menu_file_close (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

close(gcf);

% --------------------------------------------------------------------
function menu_defaults_Callback(hObject, eventdata, handles)
% hObject    handle to menu_defaults (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function menu_defaults_2PESEEM_Callback(hObject, eventdata, handles)
% hObject    handle to menu_defaults_2PESEEM (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

set(handles.tbl_pulses,'Data', {'1' '16' '10' '75';...
                                '1' '32' '10' '75'});
                            
set(handles.tbl_delays,'Data', {'1' '10'});

set(handles.tbl_echoes,'Data', {'32' '10' '1'});

PulseGenPlot(hObject, eventdata, handles)


% --------------------------------------------------------------------
function menu_defaults_IR_Callback(hObject, eventdata, handles)
% hObject    handle to menu_defaults_IR (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

set(handles.tbl_pulses,'Data', {'1' '32' '-10' '150';...
                                '1' '16' '10'  '75';...
                                '1' '32' '10'  '75'});
                            
set(handles.tbl_delays,'Data', {'1' '10'});

set(handles.tbl_echoes,'Data', {'32' '10' '1'});

PulseGenPlot(hObject, eventdata, handles)


% --------------------------------------------------------------------
function menu_defaults_DEER_Callback(hObject, eventdata, handles)
% hObject    handle to menu_defaults_DEER (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

set(handles.tbl_pulses,'Data', {'1' '16' '10'  '100';...
                                '1' '32' '10'  '200';...
                                '2' '32' '10'  '300';...
                                '1' '32' '10'  '200'});
                            
set(handles.tbl_delays,'Data', {'1' '10';...
                                '2' '200'});
                           
set(handles.tbl_echoes,'Data', {'32' '10' '1'});
PulseGenPlot(hObject, eventdata, handles)


% --------------------------------------------------------------------
function menu_help_Callback(hObject, eventdata, handles)
% hObject    handle to menu_help (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function menu_help_about_Callback(hObject, eventdata, handles)
% hObject    handle to menu_help_about (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

about = [...
' PulseGen v13.12                                                          ';...
' ===============                                                          ';...
'                                                                          ';...
' PulseGen is a program for the easy and quick plotting of EPR pulse       ';...
' patterns across multiple channels without having to manually draw them.  ';...
' This program was born out of frustration of easy and accurate pulse      ';...
' drawing options.                                                         ';...
'                                                                          ';...
' The original command line version of this program was written by Dr. F.  ';...
' Mentink and can be found commented in the program code.                  ';...
'                                                                          ';...
' The graphical user interface and several minor adjustments were made by  ';...
' Dr. M. Bye                                                               ';...
'                                                                          ';...
' Both authors are members of the Goldfarb group in the Department of      ';...
' Chemical Physics at the Weizmann Institute of Science, IL                ';...
'                                                                          ';...
' morgan.bye@weizmann.ac.il                                                ';...
' frederic.mentink@weizmann.ac.il                                          ';...
'                                                                          ';...
' This program is distributed under a Creative Commons share-alike, non-   ';...
' commerical, attribution license with no warranty.                        '];
msgbox(about,'PulseGen: Help')



%   ______                _   _                 
%  |  ____|              | | (_)                
%  | |__ _   _ _ __   ___| |_ _  ___  _ __  ___ 
%  |  __| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
%  | |  | |_| | | | | (__| |_| | (_) | | | \__ \
%  |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
%                                               
%                                               

function PulseGenPlot(hObject, eventdata, handles)

%% Original command line code from Fred
% 
% %% Pulse  sequence drawing
% % this codes aim at drawing any kind of EPR sequence including the echo, in
% % a quite easy way
% % version 1, developed by F. Mentink-Vigier for D. Goldfarb Group
% 
% clear
% 
% %% Definition of the sequence
% % sequence is a 2 dimension array, first column contains the pulse height
% % second column contain the pulse lenght,
% % third column contains the distance between pulses, except last value that
% % gives echo position
% 
% %% input user
% sequence{1}=[1,8,100;
%     1,16,100;
%     1,16,100];
% % 
% sequence{2}=[1,20,10;
%             2,20,10];
% sequence{3}=[2,20,50];
% delay{1}=10;
% delay{2}=60;
% delay{3}=90;
%     
% 
% channel_Detect=1;
% echoWidth=sequence{channel_Detect}(end,2)/4;
% echoHeight=0.6;
% shift=0;
% 
% % initialization of parameters
% for channel=1:size(sequence,2)
%     %delay{channel}=10;
%     time{channel}=0;%[1:sum(sum(a,2))];
%     b=0;
%     if channel>=2
%     shift=-max(sequence{channel}(:,1))+min((int{channel-1}))-1;
%     end
%     for J=1:size(sequence{channel},1)
%         %int(delay)=0;
%         time{channel}=[time{channel},delay{channel},delay{channel},delay{channel}+sequence{channel}(J,2),delay{channel}+sequence{channel}(J,2)];
%         int{channel}(b+1)=shift;
%         int{channel}(b+2)=shift;
%         int{channel}(b+3)=sequence{channel}(J,1)+shift;
%         int{channel}(b+4)=sequence{channel}(J,1)+shift;
%         b=b+4;
%         delay{channel}=delay{channel}+sequence{channel}(J,2)+sequence{channel}(J,3);
%     end
%     if channel==channel_Detect
%         time{channel}=[time{channel},time{channel}(end)+sequence{channel}(end,2)+sequence{channel}(end,3)-2*pi*echoWidth];
%         int{channel}(end+1)=0;int{channel}(end+1)=0;
%         data{channel}=[time{channel}',int{channel}'];
%         a=-2*pi*echoWidth:0.1:echoWidth*2*pi;
%         f=(sin(a/echoWidth)./a);
%         time{channel}=[time{channel},time{channel}(end)+2*pi*echoWidth+a,time{channel}(end)+2*pi*echoWidth+a(end)+10];
%         int{channel}=[int{channel},f/max(f)*echoHeight,0];
%         else
%         int{channel}(end+1)=shift;
%         int{channel}(end+1)=shift;
%         time{channel}(end+1)=time{channel_Detect}(end);
%         %time{channel}(end+1)=time{channel_Detect}(end);
%     end
%     figure(1); hold on; plot(time{channel},int{channel});
% end
% %plot(time,int);

%% Select and clear axis
axes(handles.axes_pulses);
cla;


%% Pulses

% Get pulses from table
pulse_def = get(handles.tbl_pulses,'Data');

% Get number of pulses and channels
noPulses   = size(pulse_def,1);
noChannels = max(str2double(pulse_def(:,1)));

% For each pulse pulse
for k = 1:noPulses
    %     sequence{str2double(pulse_def{k,1})}(k(k,1:3)) = ...
    %         [str2double(pulse_def{k,2}) ...
    %          str2double(pulse_def{k,3}) ...
    %          str2double(pulse_def{k,4})];
    sequence{str2double(pulse_def{k,1})}(k,1) = str2double(pulse_def{k,3});
    sequence{str2double(pulse_def{k,1})}(k,2) = str2double(pulse_def{k,2});
    sequence{str2double(pulse_def{k,1})}(k,3) = str2double(pulse_def{k,4});
end

for k = 1:noChannels
    sequence{1,k}(all(sequence{1,k}==0,2),:)=[];
end

%% Delays
delay_def = get(handles.tbl_delays,'Data');

noDelays = size(delay_def,1);

for k = 1:noDelays
   delay{str2double(delay_def{k,1})} = str2double(delay_def{k,2});
end


%% Echoes

% Echo only in channel 1 in current version
channel_Detect=1;

% Lookup table
echo_def   =  get(handles.tbl_echoes,'Data');

% Future versions may have mutli echo support
% for k = 1:noEchoes
echoWidth  = str2double(echo_def{1,1})/(2*pi);
echoHeight = str2double(echo_def{1,2});
echoShape  = str2double(echo_def{1,3});
shift = 0;
% end

%% Plotting

% initialization of parameters
for channel=1:size(sequence,2)
    % delay{channel}=10;
    time{channel}=0;%[1:sum(sum(a,2))];
    b=0;
    
    % If multiple channels then a shift needs to occur to spread them
    if channel>=2
        shift=-max(sequence{channel}(:,1))+min((int{channel-1}))-1;
    end
    
    % For each pulse in a channel, add it to the plot
    for J=1:size(sequence{channel},1)
        %int(delay)=0;
        time{channel}=[time{channel},delay{channel},delay{channel},delay{channel}+sequence{channel}(J,2),delay{channel}+sequence{channel}(J,2)];
        int{channel}(b+1)=shift;
        int{channel}(b+2)=shift;
        int{channel}(b+3)=sequence{channel}(J,1)+shift;
        int{channel}(b+4)=sequence{channel}(J,1)+shift;
        % int{channel}(b+5)=shift;    % added so that int and time are same size
        b=b+4;
        delay{channel}=delay{channel}+sequence{channel}(J,2)+sequence{channel}(J,3);
    end
    
    % If this channel has the echo, add echo to the end
    if channel==channel_Detect
        time{channel}=[time{channel},time{channel}(end)+sequence{channel}(end,2)+sequence{channel}(end,3)-2*pi*echoWidth];
        time{channel}=[time{channel},time{channel}(end)];
        int{channel}(end+1)=0;int{channel}(end+1)=0;
        int{channel}(end+1)=0;
        data{channel}=[time{channel}',int{channel}'];
        a=-2*pi*echoWidth:0.1:echoWidth*2*pi;
        f=(sin(a/echoWidth*echoShape)./a);
        time{channel}=[time{channel},time{channel}(end)+2*pi*echoWidth+a,time{channel}(end)+2*pi*echoWidth+a(end)+10];
        int{channel}=[int{channel},f/max(f)*echoHeight,0];

        
    % Otherwise add baseline to that channel to match the echo time
    else
        int{channel}(end+1)=shift;
        int{channel}(end+1)=shift;
        time{channel}(end+1)=time{channel_Detect}(end);
        %time{channel}(end+1)=time{channel_Detect}(end);
    end
    
    % Plot the channel
    hold on;
    plot(time{channel},int{channel});
end


%% Figure presentation
axis on;
axis tight;

ylims = get(gca,'YLim');
ylim([ylims(1)*1.1 ylims(2)*1.1]);

set(gca, 'YTick', []);
xlabel('Time / ns');
hold off;

