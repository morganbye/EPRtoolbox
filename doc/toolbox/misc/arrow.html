<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of arrow</title>
  <meta name="keywords" content="arrow">
  <meta name="description" content="ARROW  Draw a line with an arrowhead.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">toolbox</a> &gt; <a href="index.html">misc</a> &gt; arrow.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for toolbox/misc&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>arrow
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>ARROW  Draw a line with an arrowhead.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [h,yy,zz] = arrow(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ARROW  Draw a line with an arrowhead.

 Modified script, but copyright dictates that the following copyright
 information must be displayed and kept.

 Copyright (c) 2009, Erik A Johnson
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without 
 modification, are permitted provided that the following conditions are 
 met:
 
     * Redistributions of source code must retain the above copyright 
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright 
       notice, this list of conditions and the following disclaimer in 
       the documentation and/or other materials provided with the distribution
       
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 POSSIBILITY OF SUCH DAMAGE.

 Copyright (c)1995-2009, Dr. Erik A. Johnson &lt;JohnsonE@usc.edu&gt;, 5/20/2009
 http://www.usc.edu/civil_eng/johnsone/</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function out = arrow_defcheck(in,def,prop)</a></li><li><a href="#_sub2" class="code">function [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)</a></li><li><a href="#_sub3" class="code">function [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)</a></li><li><a href="#_sub4" class="code">function arrow_callback(varargin)</a></li><li><a href="#_sub5" class="code">function out = arrow_point(ax,use_z)</a></li><li><a href="#_sub6" class="code">function [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)</a></li><li><a href="#_sub7" class="code">function [out,is2D] = arrow_is2DXY(ax)</a></li><li><a href="#_sub8" class="code">function out = arrow_planarkids(ax)</a></li><li><a href="#_sub9" class="code">function arrow_fixlimits(axlimits)</a></li><li><a href="#_sub10" class="code">function out = arrow_WarpToFill(notstretched,manualcamera,curax)</a></li><li><a href="#_sub11" class="code">function out = arrow_warnlimits(axlimits,narrows)</a></li><li><a href="#_sub12" class="code">function arrow_copyprops(fm,to)</a></li><li><a href="#_sub13" class="code">function out = trueornan(x)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [h,yy,zz] = arrow(varargin)</a>
0002 <span class="comment">% ARROW  Draw a line with an arrowhead.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Modified script, but copyright dictates that the following copyright</span>
0005 <span class="comment">% information must be displayed and kept.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Copyright (c) 2009, Erik A Johnson</span>
0008 <span class="comment">% All rights reserved.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Redistribution and use in source and binary forms, with or without</span>
0011 <span class="comment">% modification, are permitted provided that the following conditions are</span>
0012 <span class="comment">% met:</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%     * Redistributions of source code must retain the above copyright</span>
0015 <span class="comment">%       notice, this list of conditions and the following disclaimer.</span>
0016 <span class="comment">%     * Redistributions in binary form must reproduce the above copyright</span>
0017 <span class="comment">%       notice, this list of conditions and the following disclaimer in</span>
0018 <span class="comment">%       the documentation and/or other materials provided with the distribution</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
0021 <span class="comment">% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
0022 <span class="comment">% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
0023 <span class="comment">% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
0024 <span class="comment">% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
0025 <span class="comment">% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
0026 <span class="comment">% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
0027 <span class="comment">% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
0028 <span class="comment">% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
0029 <span class="comment">% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
0030 <span class="comment">% POSSIBILITY OF SUCH DAMAGE.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Copyright (c)1995-2009, Dr. Erik A. Johnson &lt;JohnsonE@usc.edu&gt;, 5/20/2009</span>
0033 <span class="comment">% http://www.usc.edu/civil_eng/johnsone/</span>
0034 
0035 <span class="comment">%                                        _                             _</span>
0036 <span class="comment">%                                       | |                           | |</span>
0037 <span class="comment">%  _ __ ___   ___  _ __ __ _  __ _ _ __ | |__  _   _  ___   _ __   ___| |_</span>
0038 <span class="comment">% | '_ ` _ \ / _ \| '__/ _` |/ _` | '_ \| '_ \| | | |/ _ \ | '_ \ / _ \ __|</span>
0039 <span class="comment">% | | | | | | (_) | | | (_| | (_| | | | | |_) | |_| |  __/_| | | |  __/ |_</span>
0040 <span class="comment">% |_| |_| |_|\___/|_|  \__, |\__,_|_| |_|_.__/ \__, |\___(_)_| |_|\___|\__|</span>
0041 <span class="comment">%                       __/ |                   __/ |</span>
0042 <span class="comment">%                      |___/                   |___/</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% M. Bye v11.5</span>
0045 
0046 <span class="comment">% global variable initialization</span>
0047 <span class="keyword">global</span> ARROW_PERSP_WARN ARROW_STRETCH_WARN ARROW_AXLIMITS
0048 <span class="keyword">if</span> isempty(ARROW_PERSP_WARN  ), ARROW_PERSP_WARN  =1; <span class="keyword">end</span>;
0049 <span class="keyword">if</span> isempty(ARROW_STRETCH_WARN), ARROW_STRETCH_WARN=1; <span class="keyword">end</span>;
0050 
0051 <span class="comment">% Handle callbacks</span>
0052 <span class="keyword">if</span> (nargin&gt;0 &amp; isstr(varargin{1}) &amp; strcmp(lower(varargin{1}),<span class="string">'callback'</span>)),
0053     <a href="#_sub4" class="code" title="subfunction arrow_callback(varargin)">arrow_callback</a>(varargin{2:end}); <span class="keyword">return</span>;
0054 <span class="keyword">end</span>;
0055 
0056 <span class="comment">% Check # of arguments</span>
0057 <span class="keyword">if</span> (nargout&gt;3), error([upper(mfilename) <span class="string">' produces at most 3 output arguments.'</span>]); <span class="keyword">end</span>;
0058 
0059 <span class="comment">% find first property number</span>
0060 firstprop = nargin+1;
0061 <span class="keyword">for</span> k=1:length(varargin), <span class="keyword">if</span> ~isnumeric(varargin{k}), firstprop=k; <span class="keyword">break</span>; <span class="keyword">end</span>; <span class="keyword">end</span>;
0062 lastnumeric = firstprop-1;
0063 
0064 <span class="comment">% check property list</span>
0065 <span class="keyword">if</span> (firstprop&lt;=nargin),
0066     <span class="keyword">for</span> k=firstprop:2:nargin,
0067         curarg = varargin{k};
0068         <span class="keyword">if</span> ~isstr(curarg) | sum(size(curarg)&gt;1)&gt;1,
0069             error([upper(mfilename) <span class="string">' requires that a property name be a single string.'</span>]);
0070         <span class="keyword">end</span>;
0071     <span class="keyword">end</span>;
0072     <span class="keyword">if</span> (rem(nargin-firstprop,2)~=1),
0073         error([upper(mfilename) <span class="string">' requires that the property '''</span> <span class="keyword">...</span>
0074                varargin{nargin} <span class="string">''' be paired with a property value.'</span>]);
0075     <span class="keyword">end</span>;
0076 <span class="keyword">end</span>;
0077 
0078 <span class="comment">% default output</span>
0079 <span class="keyword">if</span> (nargout&gt;0), h=[]; <span class="keyword">end</span>;
0080 <span class="keyword">if</span> (nargout&gt;1), yy=[]; <span class="keyword">end</span>;
0081 <span class="keyword">if</span> (nargout&gt;2), zz=[]; <span class="keyword">end</span>;
0082 
0083 <span class="comment">% set values to empty matrices</span>
0084 start      = [];
0085 stop       = [];
0086 len        = [];
0087 baseangle  = [];
0088 tipangle   = [];
0089 wid        = [];
0090 page       = [];
0091 crossdir   = [];
0092 ends       = [];
0093 ax         = [];
0094 oldh       = [];
0095 ispatch    = [];
0096 defstart      = [NaN NaN NaN];
0097 defstop       = [NaN NaN NaN];
0098 deflen        = 16;
0099 defbaseangle  = 90;
0100 deftipangle   = 16;
0101 defwid        = 0;
0102 defpage       = 0;
0103 defcrossdir   = [NaN NaN NaN];
0104 defends       = 1;
0105 defoldh       = [];
0106 defispatch    = 1;
0107 
0108 <span class="comment">% The 'Tag' we'll put on our arrows</span>
0109 ArrowTag = <span class="string">'Arrow'</span>;
0110 
0111 <span class="comment">% check for oldstyle arguments</span>
0112 <span class="keyword">if</span> (firstprop==2),
0113     <span class="comment">% assume arg1 is a set of handles</span>
0114     oldh = varargin{1}(:);
0115     <span class="keyword">if</span> isempty(oldh), <span class="keyword">return</span>; <span class="keyword">end</span>;
0116 <span class="keyword">elseif</span> (firstprop&gt;9),
0117     error([upper(mfilename) <span class="string">' takes at most 8 non-property arguments.'</span>]);
0118 <span class="keyword">elseif</span> (firstprop&gt;2),
0119     {start,stop,len,baseangle,tipangle,wid,page,crossdir};
0120     args = [varargin(1:firstprop-1) cell(1,length(ans)-(firstprop-1))];
0121     [start,stop,len,baseangle,tipangle,wid,page,crossdir] = deal(args{:});
0122 <span class="keyword">end</span>;
0123 
0124 <span class="comment">% parse property pairs</span>
0125 extraprops={};
0126 <span class="keyword">for</span> k=firstprop:2:nargin,
0127     prop = varargin{k};
0128     val  = varargin{k+1};
0129     prop = [lower(prop(:)') <span class="string">'      '</span>];
0130     <span class="keyword">if</span>     strncmp(prop,<span class="string">'start'</span> ,5),   start      = val;
0131     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'stop'</span>  ,4),   stop       = val;
0132     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'len'</span>   ,3),   len        = val(:);
0133     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'base'</span>  ,4),   baseangle  = val(:);
0134     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'tip'</span>   ,3),   tipangle   = val(:);
0135     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'wid'</span>   ,3),   wid        = val(:);
0136     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'page'</span>  ,4),   page       = val;
0137     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'cross'</span> ,5),   crossdir   = val;
0138     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'norm'</span>  ,4),   <span class="keyword">if</span> (isstr(val)), crossdir=val; <span class="keyword">else</span>, crossdir=val*sqrt(-1); <span class="keyword">end</span>;
0139     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'end'</span>   ,3),   ends       = val;
0140     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'object'</span>,6),   oldh       = val(:);
0141     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'handle'</span>,6),   oldh       = val(:);
0142     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'type'</span>  ,4),   ispatch    = val;
0143     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'userd'</span> ,5),   <span class="comment">%ignore it</span>
0144     <span class="keyword">else</span>,
0145         <span class="comment">% make sure it is a valid patch or line property</span>
0146         <span class="keyword">try</span>
0147             get(0,[<span class="string">'DefaultPatch'</span> varargin{k}]);
0148         <span class="keyword">catch</span>
0149             errstr = lasterr;
0150             <span class="keyword">try</span>
0151                 get(0,[<span class="string">'DefaultLine'</span> varargin{k}]);
0152             <span class="keyword">catch</span>
0153                 errstr(1:max(find(errstr==char(13)|errstr==char(10)))) = <span class="string">''</span>;
0154                 error([upper(mfilename) <span class="string">' got '</span> errstr]);
0155             <span class="keyword">end</span>
0156         <span class="keyword">end</span>;
0157         extraprops={extraprops{:},varargin{k},val};
0158     <span class="keyword">end</span>;
0159 <span class="keyword">end</span>;
0160 
0161 <span class="comment">% Check if we got 'default' values</span>
0162 start     = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(start    ,defstart    ,<span class="string">'Start'</span>        );
0163 stop      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(stop     ,defstop     ,<span class="string">'Stop'</span>         );
0164 len       = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(len      ,deflen      ,<span class="string">'Length'</span>       );
0165 baseangle = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(baseangle,defbaseangle,<span class="string">'BaseAngle'</span>    );
0166 tipangle  = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(tipangle ,deftipangle ,<span class="string">'TipAngle'</span>     );
0167 wid       = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(wid      ,defwid      ,<span class="string">'Width'</span>        );
0168 crossdir  = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(crossdir ,defcrossdir ,<span class="string">'CrossDir'</span>     );
0169 page      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(page     ,defpage     ,<span class="string">'Page'</span>         );
0170 ends      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(ends     ,defends     ,<span class="string">''</span>             );
0171 oldh      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(oldh     ,[]          ,<span class="string">'ObjectHandles'</span>);
0172 ispatch   = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(ispatch  ,defispatch  ,<span class="string">''</span>             );
0173 
0174 <span class="comment">% check transpose on arguments</span>
0175 [m,n]=size(start   );   <span class="keyword">if</span> any(m==[2 3])&amp;(n==1|n&gt;3),   start    = start';      <span class="keyword">end</span>;
0176 [m,n]=size(stop    );   <span class="keyword">if</span> any(m==[2 3])&amp;(n==1|n&gt;3),   stop     = stop';       <span class="keyword">end</span>;
0177 [m,n]=size(crossdir);   <span class="keyword">if</span> any(m==[2 3])&amp;(n==1|n&gt;3),   crossdir = crossdir';   <span class="keyword">end</span>;
0178 
0179 <span class="comment">% convert strings to numbers</span>
0180 <span class="keyword">if</span> ~isempty(ends) &amp; isstr(ends),
0181     endsorig = ends;
0182     [m,n] = size(ends);
0183     col = lower([ends(:,1:min(3,n)) ones(m,max(0,3-n))*<span class="string">' '</span>]);
0184     ends = NaN*ones(m,1);
0185     oo = ones(1,m);
0186     ii=find(all(col'==[<span class="string">'non'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*0; <span class="keyword">end</span>;
0187     ii=find(all(col'==[<span class="string">'sto'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*1; <span class="keyword">end</span>;
0188     ii=find(all(col'==[<span class="string">'sta'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*2; <span class="keyword">end</span>;
0189     ii=find(all(col'==[<span class="string">'bot'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*3; <span class="keyword">end</span>;
0190     <span class="keyword">if</span> any(isnan(ends)),
0191         ii = min(find(isnan(ends)));
0192         error([upper(mfilename) <span class="string">' does not recognize '''</span> deblank(endsorig(ii,:)) <span class="string">''' as a valid ''Ends'' value.'</span>]);
0193     <span class="keyword">end</span>;
0194 <span class="keyword">else</span>,
0195     ends = ends(:);
0196 <span class="keyword">end</span>;
0197 <span class="keyword">if</span> ~isempty(ispatch) &amp; isstr(ispatch),
0198     col = lower(ispatch(:,1));
0199     patchchar=<span class="string">'p'</span>; linechar=<span class="string">'l'</span>; defchar=<span class="string">' '</span>;
0200     mask = col~=patchchar &amp; col~=linechar &amp; col~=defchar;
0201     <span class="keyword">if</span> any(mask),
0202         error([upper(mfilename) <span class="string">' does not recognize '''</span> deblank(ispatch(min(find(mask)),:)) <span class="string">''' as a valid ''Type'' value.'</span>]);
0203     <span class="keyword">end</span>;
0204     ispatch = (col==patchchar)*1 + (col==linechar)*0 + (col==defchar)*defispatch;
0205 <span class="keyword">else</span>,
0206     ispatch = ispatch(:);
0207 <span class="keyword">end</span>;
0208 oldh = oldh(:);
0209 
0210 <span class="comment">% check object handles</span>
0211 <span class="keyword">if</span> ~all(ishandle(oldh)), error([upper(mfilename) <span class="string">' got invalid object handles.'</span>]); <span class="keyword">end</span>;
0212 
0213 <span class="comment">% expand root, figure, and axes handles</span>
0214 <span class="keyword">if</span> ~isempty(oldh),
0215     ohtype = get(oldh,<span class="string">'Type'</span>);
0216     mask = strcmp(ohtype,<span class="string">'root'</span>) | strcmp(ohtype,<span class="string">'figure'</span>) | strcmp(ohtype,<span class="string">'axes'</span>);
0217     <span class="keyword">if</span> any(mask),
0218         oldh = num2cell(oldh);
0219         <span class="keyword">for</span> ii=find(mask)',
0220             oldh(ii) = {findobj(oldh{ii},<span class="string">'Tag'</span>,ArrowTag)};
0221         <span class="keyword">end</span>;
0222         oldh = cat(1,oldh{:});
0223         <span class="keyword">if</span> isempty(oldh), <span class="keyword">return</span>; <span class="keyword">end</span>; <span class="comment">% no arrows to modify, so just leave</span>
0224     <span class="keyword">end</span>;
0225 <span class="keyword">end</span>;
0226 
0227 <span class="comment">% largest argument length</span>
0228 [mstart,junk]=size(start); [mstop,junk]=size(stop); [mcrossdir,junk]=size(crossdir);
0229 argsizes = [length(oldh) mstart mstop                              <span class="keyword">...</span>
0230             length(len) length(baseangle) length(tipangle)         <span class="keyword">...</span>
0231             length(wid) length(page) mcrossdir length(ends) ];
0232 args=[<span class="string">'length(ObjectHandle)  '</span>; <span class="keyword">...</span>
0233       <span class="string">'#rows(Start)          '</span>; <span class="keyword">...</span>
0234       <span class="string">'#rows(Stop)           '</span>; <span class="keyword">...</span>
0235       <span class="string">'length(Length)        '</span>; <span class="keyword">...</span>
0236       <span class="string">'length(BaseAngle)     '</span>; <span class="keyword">...</span>
0237       <span class="string">'length(TipAngle)      '</span>; <span class="keyword">...</span>
0238       <span class="string">'length(Width)         '</span>; <span class="keyword">...</span>
0239       <span class="string">'length(Page)          '</span>; <span class="keyword">...</span>
0240       <span class="string">'#rows(CrossDir)       '</span>; <span class="keyword">...</span>
0241       <span class="string">'#rows(Ends)           '</span>];
0242 <span class="keyword">if</span> (any(imag(crossdir(:))~=0)),
0243     args(9,:) = <span class="string">'#rows(NormalDir)      '</span>;
0244 <span class="keyword">end</span>;
0245 <span class="keyword">if</span> isempty(oldh),
0246     narrows = max(argsizes);
0247 <span class="keyword">else</span>,
0248     narrows = length(oldh);
0249 <span class="keyword">end</span>;
0250 <span class="keyword">if</span> (narrows&lt;=0), narrows=1; <span class="keyword">end</span>;
0251 
0252 <span class="comment">% Check size of arguments</span>
0253 ii = find((argsizes~=0)&amp;(argsizes~=1)&amp;(argsizes~=narrows));
0254 <span class="keyword">if</span> ~isempty(ii),
0255     s = args(ii',:);
0256     <span class="keyword">while</span> ((size(s,2)&gt;1)&amp;((abs(s(:,size(s,2)))==0)|(abs(s(:,size(s,2)))==abs(<span class="string">' '</span>)))),
0257         s = s(:,1:size(s,2)-1);
0258     <span class="keyword">end</span>;
0259     s = [ones(length(ii),1)*[upper(mfilename) <span class="string">' requires that  '</span>] s <span class="keyword">...</span>
0260          ones(length(ii),1)*[<span class="string">'  equal the # of arrows ('</span> num2str(narrows) <span class="string">').'</span> c]];
0261     s = s';
0262     s = s(:)';
0263     s = s(1:length(s)-1);
0264     error(setstr(s));
0265 <span class="keyword">end</span>;
0266 
0267 <span class="comment">% check element length in Start, Stop, and CrossDir</span>
0268 <span class="keyword">if</span> ~isempty(start),
0269     [m,n] = size(start);
0270     <span class="keyword">if</span> (n==2),
0271         start = [start NaN*ones(m,1)];
0272     <span class="keyword">elseif</span> (n~=3),
0273         error([upper(mfilename) <span class="string">' requires 2- or 3-element Start points.'</span>]);
0274     <span class="keyword">end</span>;
0275 <span class="keyword">end</span>;
0276 <span class="keyword">if</span> ~isempty(stop),
0277     [m,n] = size(stop);
0278     <span class="keyword">if</span> (n==2),
0279         stop = [stop NaN*ones(m,1)];
0280     <span class="keyword">elseif</span> (n~=3),
0281         error([upper(mfilename) <span class="string">' requires 2- or 3-element Stop points.'</span>]);
0282     <span class="keyword">end</span>;
0283 <span class="keyword">end</span>;
0284 <span class="keyword">if</span> ~isempty(crossdir),
0285     [m,n] = size(crossdir);
0286     <span class="keyword">if</span> (n&lt;3),
0287         crossdir = [crossdir NaN*ones(m,3-n)];
0288     <span class="keyword">elseif</span> (n~=3),
0289         <span class="keyword">if</span> (all(imag(crossdir(:))==0)),
0290             error([upper(mfilename) <span class="string">' requires 2- or 3-element CrossDir vectors.'</span>]);
0291         <span class="keyword">else</span>,
0292             error([upper(mfilename) <span class="string">' requires 2- or 3-element NormalDir vectors.'</span>]);
0293         <span class="keyword">end</span>;
0294     <span class="keyword">end</span>;
0295 <span class="keyword">end</span>;
0296 
0297 <span class="comment">% fill empty arguments</span>
0298 <span class="keyword">if</span> isempty(start     ),   start      = [Inf Inf Inf];      <span class="keyword">end</span>;
0299 <span class="keyword">if</span> isempty(stop      ),   stop       = [Inf Inf Inf];      <span class="keyword">end</span>;
0300 <span class="keyword">if</span> isempty(len       ),   len        = Inf;                <span class="keyword">end</span>;
0301 <span class="keyword">if</span> isempty(baseangle ),   baseangle  = Inf;                <span class="keyword">end</span>;
0302 <span class="keyword">if</span> isempty(tipangle  ),   tipangle   = Inf;                <span class="keyword">end</span>;
0303 <span class="keyword">if</span> isempty(wid       ),   wid        = Inf;                <span class="keyword">end</span>;
0304 <span class="keyword">if</span> isempty(page      ),   page       = Inf;                <span class="keyword">end</span>;
0305 <span class="keyword">if</span> isempty(crossdir  ),   crossdir   = [Inf Inf Inf];      <span class="keyword">end</span>;
0306 <span class="keyword">if</span> isempty(ends      ),   ends       = Inf;                <span class="keyword">end</span>;
0307 <span class="keyword">if</span> isempty(ispatch   ),   ispatch    = Inf;                <span class="keyword">end</span>;
0308 
0309 <span class="comment">% expand single-column arguments</span>
0310 o = ones(narrows,1);
0311 <span class="keyword">if</span> (size(start     ,1)==1),   start      = o * start     ;   <span class="keyword">end</span>;
0312 <span class="keyword">if</span> (size(stop      ,1)==1),   stop       = o * stop      ;   <span class="keyword">end</span>;
0313 <span class="keyword">if</span> (length(len       )==1),   len        = o * len       ;   <span class="keyword">end</span>;
0314 <span class="keyword">if</span> (length(baseangle )==1),   baseangle  = o * baseangle ;   <span class="keyword">end</span>;
0315 <span class="keyword">if</span> (length(tipangle  )==1),   tipangle   = o * tipangle  ;   <span class="keyword">end</span>;
0316 <span class="keyword">if</span> (length(wid       )==1),   wid        = o * wid       ;   <span class="keyword">end</span>;
0317 <span class="keyword">if</span> (length(page      )==1),   page       = o * page      ;   <span class="keyword">end</span>;
0318 <span class="keyword">if</span> (size(crossdir  ,1)==1),   crossdir   = o * crossdir  ;   <span class="keyword">end</span>;
0319 <span class="keyword">if</span> (length(ends      )==1),   ends       = o * ends      ;   <span class="keyword">end</span>;
0320 <span class="keyword">if</span> (length(ispatch   )==1),   ispatch    = o * ispatch   ;   <span class="keyword">end</span>;
0321 ax = o * gca;
0322 
0323 <span class="comment">% if we've got handles, get the defaults from the handles</span>
0324 <span class="keyword">if</span> ~isempty(oldh),
0325     <span class="keyword">for</span> k=1:narrows,
0326         oh = oldh(k);
0327         ud = get(oh,<span class="string">'UserData'</span>);
0328         ax(k) = get(oh,<span class="string">'Parent'</span>);
0329         ohtype = get(oh,<span class="string">'Type'</span>);
0330         <span class="keyword">if</span> strcmp(get(oh,<span class="string">'Tag'</span>),ArrowTag), <span class="comment">% if it's an arrow already</span>
0331             <span class="keyword">if</span> isinf(ispatch(k)), ispatch(k)=strcmp(ohtype,<span class="string">'patch'</span>); <span class="keyword">end</span>;
0332             <span class="comment">% arrow UserData format: [start' stop' len base tip wid page crossdir' ends]</span>
0333             start0 = ud(1:3);
0334             stop0  = ud(4:6);
0335             <span class="keyword">if</span> (isinf(len(k))),           len(k)        = ud( 7);   <span class="keyword">end</span>;
0336             <span class="keyword">if</span> (isinf(baseangle(k))),     baseangle(k)  = ud( 8);   <span class="keyword">end</span>;
0337             <span class="keyword">if</span> (isinf(tipangle(k))),      tipangle(k)   = ud( 9);   <span class="keyword">end</span>;
0338             <span class="keyword">if</span> (isinf(wid(k))),           wid(k)        = ud(10);   <span class="keyword">end</span>;
0339             <span class="keyword">if</span> (isinf(page(k))),          page(k)       = ud(11);   <span class="keyword">end</span>;
0340             <span class="keyword">if</span> (isinf(crossdir(k,1))),    crossdir(k,1) = ud(12);   <span class="keyword">end</span>;
0341             <span class="keyword">if</span> (isinf(crossdir(k,2))),    crossdir(k,2) = ud(13);   <span class="keyword">end</span>;
0342             <span class="keyword">if</span> (isinf(crossdir(k,3))),    crossdir(k,3) = ud(14);   <span class="keyword">end</span>;
0343             <span class="keyword">if</span> (isinf(ends(k))),          ends(k)       = ud(15);   <span class="keyword">end</span>;
0344         <span class="keyword">elseif</span> strcmp(ohtype,<span class="string">'line'</span>)|strcmp(ohtype,<span class="string">'patch'</span>), <span class="comment">% it's a non-arrow line or patch</span>
0345             convLineToPatch = 1; <span class="comment">%set to make arrow patches when converting from lines.</span>
0346             <span class="keyword">if</span> isinf(ispatch(k)), ispatch(k)=convLineToPatch|strcmp(ohtype,<span class="string">'patch'</span>); <span class="keyword">end</span>;
0347             x=get(oh,<span class="string">'XData'</span>);  x=x(~isnan(x(:)));  <span class="keyword">if</span> isempty(x), x=NaN; <span class="keyword">end</span>;
0348             y=get(oh,<span class="string">'YData'</span>);  y=y(~isnan(y(:)));  <span class="keyword">if</span> isempty(y), y=NaN; <span class="keyword">end</span>;
0349             z=get(oh,<span class="string">'ZData'</span>);  z=z(~isnan(z(:)));  <span class="keyword">if</span> isempty(z), z=NaN; <span class="keyword">end</span>;
0350             start0 = [x(1)   y(1)   z(1)  ];
0351             stop0  = [x(end) y(end) z(end)];
0352         <span class="keyword">else</span>,
0353             error([upper(mfilename) <span class="string">' cannot convert '</span> ohtype <span class="string">' objects.'</span>]);
0354         <span class="keyword">end</span>;
0355         ii=find(isinf(start(k,:)));  <span class="keyword">if</span> ~isempty(ii),  start(k,ii)=start0(ii);  <span class="keyword">end</span>;
0356         ii=find(isinf(stop( k,:)));  <span class="keyword">if</span> ~isempty(ii),  stop( k,ii)=stop0( ii);  <span class="keyword">end</span>;
0357     <span class="keyword">end</span>;
0358 <span class="keyword">end</span>;
0359 
0360 <span class="comment">% convert Inf's to NaN's</span>
0361 start(     isinf(start    )) = NaN;
0362 stop(      isinf(stop     )) = NaN;
0363 len(       isinf(len      )) = NaN;
0364 baseangle( isinf(baseangle)) = NaN;
0365 tipangle(  isinf(tipangle )) = NaN;
0366 wid(       isinf(wid      )) = NaN;
0367 page(      isinf(page     )) = NaN;
0368 crossdir(  isinf(crossdir )) = NaN;
0369 ends(      isinf(ends     )) = NaN;
0370 ispatch(   isinf(ispatch  )) = NaN;
0371 
0372 <span class="comment">% set up the UserData data (here so not corrupted by log10's and such)</span>
0373 ud = [start stop len baseangle tipangle wid page crossdir ends];
0374 
0375 <span class="comment">% Set Page defaults</span>
0376 page = ~isnan(page) &amp; <a href="#_sub13" class="code" title="subfunction out = trueornan(x)">trueornan</a>(page);
0377 
0378 <span class="comment">% Get axes limits, range, min; correct for aspect ratio and log scale</span>
0379 axm       = zeros(3,narrows);
0380 axr       = zeros(3,narrows);
0381 axrev     = zeros(3,narrows);
0382 ap        = zeros(2,narrows);
0383 xyzlog    = zeros(3,narrows);
0384 limmin    = zeros(2,narrows);
0385 limrange  = zeros(2,narrows);
0386 oldaxlims = zeros(narrows,7);
0387 oneax = all(ax==ax(1));
0388 <span class="keyword">if</span> (oneax),
0389     T    = zeros(4,4);
0390     invT = zeros(4,4);
0391 <span class="keyword">else</span>,
0392     T    = zeros(16,narrows);
0393     invT = zeros(16,narrows);
0394 <span class="keyword">end</span>;
0395 axnotdone = logical(ones(size(ax)));
0396 <span class="keyword">while</span> (any(axnotdone)),
0397     ii = min(find(axnotdone));
0398     curax = ax(ii);
0399     curpage = page(ii);
0400     <span class="comment">% get axes limits and aspect ratio</span>
0401     axl = [get(curax,<span class="string">'XLim'</span>); get(curax,<span class="string">'YLim'</span>); get(curax,<span class="string">'ZLim'</span>)];
0402     oldaxlims(min(find(oldaxlims(:,1)==0)),:) = [curax reshape(axl',1,6)];
0403     <span class="comment">% get axes size in pixels (points)</span>
0404     u = get(curax,<span class="string">'Units'</span>);
0405     axposoldunits = get(curax,<span class="string">'Position'</span>);
0406     really_curpage = curpage &amp; strcmp(u,<span class="string">'normalized'</span>);
0407     <span class="keyword">if</span> (really_curpage),
0408         curfig = get(curax,<span class="string">'Parent'</span>);
0409         pu = get(curfig,<span class="string">'PaperUnits'</span>);
0410         set(curfig,<span class="string">'PaperUnits'</span>,<span class="string">'points'</span>);
0411         pp = get(curfig,<span class="string">'PaperPosition'</span>);
0412         set(curfig,<span class="string">'PaperUnits'</span>,pu);
0413         set(curax,<span class="string">'Units'</span>,<span class="string">'pixels'</span>);
0414         curapscreen = get(curax,<span class="string">'Position'</span>);
0415         set(curax,<span class="string">'Units'</span>,<span class="string">'normalized'</span>);
0416         curap = pp.*get(curax,<span class="string">'Position'</span>);
0417     <span class="keyword">else</span>,
0418         set(curax,<span class="string">'Units'</span>,<span class="string">'pixels'</span>);
0419         curapscreen = get(curax,<span class="string">'Position'</span>);
0420         curap = curapscreen;
0421     <span class="keyword">end</span>;
0422     set(curax,<span class="string">'Units'</span>,u);
0423     set(curax,<span class="string">'Position'</span>,axposoldunits);
0424     <span class="comment">% handle non-stretched axes position</span>
0425     str_stretch = { <span class="string">'DataAspectRatioMode'</span>    ; <span class="keyword">...</span>
0426                     <span class="string">'PlotBoxAspectRatioMode'</span> ; <span class="keyword">...</span>
0427                     <span class="string">'CameraViewAngleMode'</span>      };
0428     str_camera  = { <span class="string">'CameraPositionMode'</span>  ; <span class="keyword">...</span>
0429                     <span class="string">'CameraTargetMode'</span>    ; <span class="keyword">...</span>
0430                     <span class="string">'CameraViewAngleMode'</span> ; <span class="keyword">...</span>
0431                     <span class="string">'CameraUpVectorMode'</span>    };
0432     notstretched = strcmp(get(curax,str_stretch),<span class="string">'manual'</span>);
0433     manualcamera = strcmp(get(curax,str_camera),<span class="string">'manual'</span>);
0434     <span class="keyword">if</span> ~<a href="#_sub10" class="code" title="subfunction out = arrow_WarpToFill(notstretched,manualcamera,curax)">arrow_WarpToFill</a>(notstretched,manualcamera,curax),
0435         <span class="comment">% give a warning that this has not been thoroughly tested</span>
0436         <span class="keyword">if</span> 0 &amp; ARROW_STRETCH_WARN,
0437             ARROW_STRETCH_WARN = 0;
0438             strs = {str_stretch{1:2},str_camera{:}};
0439             strs = [char(ones(length(strs),1)*sprintf(<span class="string">'\n    '</span>)) char(strs)]';
0440             warning([upper(mfilename) <span class="string">' may not yet work quite right '</span> <span class="keyword">...</span>
0441                      <span class="string">'if any of the following are ''manual'':'</span> strs(:).']);
0442         <span class="keyword">end</span>;
0443         <span class="comment">% find the true pixel size of the actual axes</span>
0444         texttmp = text(axl(1,[1 2 2 1 1 2 2 1]), <span class="keyword">...</span>
0445                        axl(2,[1 1 2 2 1 1 2 2]), <span class="keyword">...</span>
0446                        axl(3,[1 1 1 1 2 2 2 2]),<span class="string">''</span>);
0447         set(texttmp,<span class="string">'Units'</span>,<span class="string">'points'</span>);
0448         textpos = get(texttmp,<span class="string">'Position'</span>);
0449         delete(texttmp);
0450         textpos = cat(1,textpos{:});
0451         textpos = max(textpos(:,1:2)) - min(textpos(:,1:2));
0452         <span class="comment">% adjust the axes position</span>
0453         <span class="keyword">if</span> (really_curpage),
0454             <span class="comment">% adjust to printed size</span>
0455             textpos = textpos * min(curap(3:4)./textpos);
0456             curap = [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
0457         <span class="keyword">else</span>,
0458             <span class="comment">% adjust for pixel roundoff</span>
0459             textpos = textpos * min(curapscreen(3:4)./textpos);
0460             curap = [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
0461         <span class="keyword">end</span>;
0462     <span class="keyword">end</span>;
0463     <span class="keyword">if</span> ARROW_PERSP_WARN &amp; ~strcmp(get(curax,<span class="string">'Projection'</span>),<span class="string">'orthographic'</span>),
0464         ARROW_PERSP_WARN = 0;
0465         warning([upper(mfilename) <span class="string">' does not yet work right for 3-D perspective projection.'</span>]);
0466     <span class="keyword">end</span>;
0467     <span class="comment">% adjust limits for log scale on axes</span>
0468     curxyzlog = [strcmp(get(curax,<span class="string">'XScale'</span>),<span class="string">'log'</span>); <span class="keyword">...</span>
0469                  strcmp(get(curax,<span class="string">'YScale'</span>),<span class="string">'log'</span>); <span class="keyword">...</span>
0470                  strcmp(get(curax,<span class="string">'ZScale'</span>),<span class="string">'log'</span>)];
0471     <span class="keyword">if</span> (any(curxyzlog)),
0472         ii = find([curxyzlog;curxyzlog]);
0473         <span class="keyword">if</span> (any(axl(ii)&lt;=0)),
0474             error([upper(mfilename) <span class="string">' does not support non-positive limits on log-scaled axes.'</span>]);
0475         <span class="keyword">else</span>,
0476             axl(ii) = log10(axl(ii));
0477         <span class="keyword">end</span>;
0478     <span class="keyword">end</span>;
0479     <span class="comment">% correct for 'reverse' direction on axes;</span>
0480     curreverse = [strcmp(get(curax,<span class="string">'XDir'</span>),<span class="string">'reverse'</span>); <span class="keyword">...</span>
0481                   strcmp(get(curax,<span class="string">'YDir'</span>),<span class="string">'reverse'</span>); <span class="keyword">...</span>
0482                   strcmp(get(curax,<span class="string">'ZDir'</span>),<span class="string">'reverse'</span>)];
0483     ii = find(curreverse);
0484     <span class="keyword">if</span> ~isempty(ii),
0485         axl(ii,[1 2])=-axl(ii,[2 1]);
0486     <span class="keyword">end</span>;
0487     <span class="comment">% compute the range of 2-D values</span>
0488     curT = get(curax,<span class="string">'Xform'</span>);
0489     lim = curT*[0 1 0 1 0 1 0 1;0 0 1 1 0 0 1 1;0 0 0 0 1 1 1 1;1 1 1 1 1 1 1 1];
0490     lim = lim(1:2,:)./([1;1]*lim(4,:));
0491     curlimmin = min(lim')';
0492     curlimrange = max(lim')' - curlimmin;
0493     curinvT = inv(curT);
0494     <span class="keyword">if</span> (~oneax),
0495         curT = curT.';
0496         curinvT = curinvT.';
0497         curT = curT(:);
0498         curinvT = curinvT(:);
0499     <span class="keyword">end</span>;
0500     <span class="comment">% check which arrows to which cur corresponds</span>
0501     ii = find((ax==curax)&amp;(page==curpage));
0502     oo = ones(1,length(ii));
0503     axr(:,ii)      = diff(axl')' * oo;
0504     axm(:,ii)      = axl(:,1)    * oo;
0505     axrev(:,ii)    = curreverse  * oo;
0506     ap(:,ii)       = curap(3:4)' * oo;
0507     xyzlog(:,ii)   = curxyzlog   * oo;
0508     limmin(:,ii)   = curlimmin   * oo;
0509     limrange(:,ii) = curlimrange * oo;
0510     <span class="keyword">if</span> (oneax),
0511         T    = curT;
0512         invT = curinvT;
0513     <span class="keyword">else</span>,
0514         T(:,ii)    = curT    * oo;
0515         invT(:,ii) = curinvT * oo;
0516     <span class="keyword">end</span>;
0517     axnotdone(ii) = zeros(1,length(ii));
0518 <span class="keyword">end</span>;
0519 oldaxlims(oldaxlims(:,1)==0,:)=[];
0520 
0521 <span class="comment">% correct for log scales</span>
0522 curxyzlog = xyzlog.';
0523 ii = find(curxyzlog(:));
0524 <span class="keyword">if</span> ~isempty(ii),
0525     start(   ii) = real(log10(start(   ii)));
0526     stop(    ii) = real(log10(stop(    ii)));
0527     <span class="keyword">if</span> (all(imag(crossdir)==0)), <span class="comment">% pulled (ii) subscript on crossdir, 12/5/96 eaj</span>
0528         crossdir(ii) = real(log10(crossdir(ii)));
0529     <span class="keyword">end</span>;
0530 <span class="keyword">end</span>;
0531 
0532 <span class="comment">% correct for reverse directions</span>
0533 ii = find(axrev.');
0534 <span class="keyword">if</span> ~isempty(ii),
0535     start(   ii) = -start(   ii);
0536     stop(    ii) = -stop(    ii);
0537     crossdir(ii) = -crossdir(ii);
0538 <span class="keyword">end</span>;
0539 
0540 <span class="comment">% transpose start/stop values</span>
0541 start     = start.';
0542 stop      = stop.';
0543 
0544 <span class="comment">% take care of defaults, page was done above</span>
0545 ii=find(isnan(start(:)       ));  <span class="keyword">if</span> ~isempty(ii),  start(ii)       = axm(ii)+axr(ii)/2;                <span class="keyword">end</span>;
0546 ii=find(isnan(stop(:)        ));  <span class="keyword">if</span> ~isempty(ii),  stop(ii)        = axm(ii)+axr(ii)/2;                <span class="keyword">end</span>;
0547 ii=find(isnan(crossdir(:)    ));  <span class="keyword">if</span> ~isempty(ii),  crossdir(ii)    = zeros(length(ii),1);              <span class="keyword">end</span>;
0548 ii=find(isnan(len            ));  <span class="keyword">if</span> ~isempty(ii),  len(ii)         = ones(length(ii),1)*deflen;        <span class="keyword">end</span>;
0549 ii=find(isnan(baseangle      ));  <span class="keyword">if</span> ~isempty(ii),  baseangle(ii)   = ones(length(ii),1)*defbaseangle;  <span class="keyword">end</span>;
0550 ii=find(isnan(tipangle       ));  <span class="keyword">if</span> ~isempty(ii),  tipangle(ii)    = ones(length(ii),1)*deftipangle;   <span class="keyword">end</span>;
0551 ii=find(isnan(wid            ));  <span class="keyword">if</span> ~isempty(ii),  wid(ii)         = ones(length(ii),1)*defwid;        <span class="keyword">end</span>;
0552 ii=find(isnan(ends           ));  <span class="keyword">if</span> ~isempty(ii),  ends(ii)        = ones(length(ii),1)*defends;       <span class="keyword">end</span>;
0553 
0554 <span class="comment">% transpose rest of values</span>
0555 len       = len.';
0556 baseangle = baseangle.';
0557 tipangle  = tipangle.';
0558 wid       = wid.';
0559 page      = page.';
0560 crossdir  = crossdir.';
0561 ends      = ends.';
0562 ax        = ax.';
0563 
0564 <span class="comment">% given x, a 3xN matrix of points in 3-space;</span>
0565 <span class="comment">% want to convert to X, the corresponding 4xN 2-space matrix</span>
0566 <span class="comment">%</span>
0567 <span class="comment">%   tmp1=[(x-axm)./axr; ones(1,size(x,1))];</span>
0568 <span class="comment">%   if (oneax), X=T*tmp1;</span>
0569 <span class="comment">%   else, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;</span>
0570 <span class="comment">%         tmp2=zeros(4,4*N); tmp2(:)=tmp1(:);</span>
0571 <span class="comment">%         X=zeros(4,N); X(:)=sum(tmp2)'; end;</span>
0572 <span class="comment">%   X = X ./ (ones(4,1)*X(4,:));</span>
0573 
0574 <span class="comment">% for all points with start==stop, start=stop-(verysmallvalue)*(up-direction);</span>
0575 ii = find(all(start==stop));
0576 <span class="keyword">if</span> ~isempty(ii),
0577     <span class="comment">% find an arrowdir vertical on screen and perpendicular to viewer</span>
0578     <span class="comment">%    transform to 2-D</span>
0579         tmp1 = [(stop(:,ii)-axm(:,ii))./axr(:,ii);ones(1,length(ii))];
0580         <span class="keyword">if</span> (oneax), twoD=T*tmp1;
0581         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,ii).*tmp1;
0582               tmp2=zeros(4,4*length(ii)); tmp2(:)=tmp1(:);
0583               twoD=zeros(4,length(ii)); twoD(:)=sum(tmp2)'; <span class="keyword">end</span>;
0584         twoD=twoD./(ones(4,1)*twoD(4,:));
0585     <span class="comment">%    move the start point down just slightly</span>
0586         tmp1 = twoD + [0;-1/1000;0;0]*(limrange(2,ii)./ap(2,ii));
0587     <span class="comment">%    transform back to 3-D</span>
0588         <span class="keyword">if</span> (oneax), threeD=invT*tmp1;
0589         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT(:,ii).*tmp1;
0590               tmp2=zeros(4,4*length(ii)); tmp2(:)=tmp1(:);
0591               threeD=zeros(4,length(ii)); threeD(:)=sum(tmp2)'; <span class="keyword">end</span>;
0592         start(:,ii) = (threeD(1:3,:)./(ones(3,1)*threeD(4,:))).*axr(:,ii)+axm(:,ii);
0593 <span class="keyword">end</span>;
0594 
0595 <span class="comment">% compute along-arrow points</span>
0596 <span class="comment">%    transform Start points</span>
0597     tmp1=[(start-axm)./axr;ones(1,narrows)];
0598     <span class="keyword">if</span> (oneax), X0=T*tmp1;
0599     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;
0600           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0601           X0=zeros(4,narrows); X0(:)=sum(tmp2)'; <span class="keyword">end</span>;
0602     X0=X0./(ones(4,1)*X0(4,:));
0603 <span class="comment">%    transform Stop points</span>
0604     tmp1=[(stop-axm)./axr;ones(1,narrows)];
0605     <span class="keyword">if</span> (oneax), Xf=T*tmp1;
0606     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;
0607           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0608           Xf=zeros(4,narrows); Xf(:)=sum(tmp2)'; <span class="keyword">end</span>;
0609     Xf=Xf./(ones(4,1)*Xf(4,:));
0610 <span class="comment">%    compute pixel distance between points</span>
0611     D = sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*(ap./limrange)).^2));
0612     D = D + (D==0);  <span class="comment">%eaj new 2/24/98</span>
0613 <span class="comment">%    compute and modify along-arrow distances</span>
0614     len1 = len;
0615     len2 = len - (len.*tan(tipangle/180*pi)-wid/2).*tan((90-baseangle)/180*pi);
0616     slen0 = zeros(1,narrows);
0617     slen1 = len1 .* ((ends==2)|(ends==3));
0618     slen2 = len2 .* ((ends==2)|(ends==3));
0619     len0 = zeros(1,narrows);
0620     len1  = len1 .* ((ends==1)|(ends==3));
0621     len2  = len2 .* ((ends==1)|(ends==3));
0622     <span class="comment">%    for no start arrowhead</span>
0623         ii=find((ends==1)&amp;(D&lt;len2));
0624         <span class="keyword">if</span> ~isempty(ii),
0625             slen0(ii) = D(ii)-len2(ii);
0626         <span class="keyword">end</span>;
0627     <span class="comment">%    for no end arrowhead</span>
0628         ii=find((ends==2)&amp;(D&lt;slen2));
0629         <span class="keyword">if</span> ~isempty(ii),
0630             len0(ii) = D(ii)-slen2(ii);
0631         <span class="keyword">end</span>;
0632     len1  = len1  + len0;
0633     len2  = len2  + len0;
0634     slen1 = slen1 + slen0;
0635     slen2 = slen2 + slen0;
0636      <span class="comment">% note:  the division by D below will probably not be accurate if both</span>
0637      <span class="comment">%        of the following are true:</span>
0638      <span class="comment">%           1. the ratio of the line length to the arrowhead</span>
0639      <span class="comment">%              length is large</span>
0640      <span class="comment">%           2. the view is highly perspective.</span>
0641 <span class="comment">%    compute stoppoints</span>
0642     tmp1=X0.*(ones(4,1)*(len0./D))+Xf.*(ones(4,1)*(1-len0./D));
0643     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0644     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0645           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0646           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0647     stoppoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0648 <span class="comment">%    compute tippoints</span>
0649     tmp1=X0.*(ones(4,1)*(len1./D))+Xf.*(ones(4,1)*(1-len1./D));
0650     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0651     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0652           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0653           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0654     tippoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0655 <span class="comment">%    compute basepoints</span>
0656     tmp1=X0.*(ones(4,1)*(len2./D))+Xf.*(ones(4,1)*(1-len2./D));
0657     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0658     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0659           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0660           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0661     basepoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0662 <span class="comment">%    compute startpoints</span>
0663     tmp1=X0.*(ones(4,1)*(1-slen0./D))+Xf.*(ones(4,1)*(slen0./D));
0664     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0665     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0666           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0667           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0668     startpoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0669 <span class="comment">%    compute stippoints</span>
0670     tmp1=X0.*(ones(4,1)*(1-slen1./D))+Xf.*(ones(4,1)*(slen1./D));
0671     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0672     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0673           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0674           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0675     stippoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0676 <span class="comment">%    compute sbasepoints</span>
0677     tmp1=X0.*(ones(4,1)*(1-slen2./D))+Xf.*(ones(4,1)*(slen2./D));
0678     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0679     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0680           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0681           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0682     sbasepoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0683 
0684 <span class="comment">% compute cross-arrow directions for arrows with NormalDir specified</span>
0685 <span class="keyword">if</span> (any(imag(crossdir(:))~=0)),
0686     ii = find(any(imag(crossdir)~=0));
0687     crossdir(:,ii) = cross((stop(:,ii)-start(:,ii))./axr(:,ii), <span class="keyword">...</span>
0688                            imag(crossdir(:,ii))).*axr(:,ii);
0689 <span class="keyword">end</span>;
0690 
0691 <span class="comment">% compute cross-arrow directions</span>
0692 basecross  = crossdir + basepoint;
0693 tipcross   = crossdir + tippoint;
0694 sbasecross = crossdir + sbasepoint;
0695 stipcross  = crossdir + stippoint;
0696 ii = find(all(crossdir==0)|any(isnan(crossdir)));
0697 <span class="keyword">if</span> ~isempty(ii),
0698     numii = length(ii);
0699     <span class="comment">%    transform start points</span>
0700         tmp1 = [basepoint(:,ii) tippoint(:,ii) sbasepoint(:,ii) stippoint(:,ii)];
0701         tmp1 = (tmp1-axm(:,[ii ii ii ii])) ./ axr(:,[ii ii ii ii]);
0702         tmp1 = [tmp1; ones(1,4*numii)];
0703         <span class="keyword">if</span> (oneax), X0=T*tmp1;
0704         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,[ii ii ii ii]).*tmp1;
0705               tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
0706               X0=zeros(4,4*numii); X0(:)=sum(tmp2)'; <span class="keyword">end</span>;
0707         X0=X0./(ones(4,1)*X0(4,:));
0708     <span class="comment">%    transform stop points</span>
0709         tmp1 = [(2*stop(:,ii)-start(:,ii)-axm(:,ii))./axr(:,ii);ones(1,numii)];
0710         tmp1 = [tmp1 tmp1 tmp1 tmp1];
0711         <span class="keyword">if</span> (oneax), Xf=T*tmp1;
0712         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,[ii ii ii ii]).*tmp1;
0713               tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
0714               Xf=zeros(4,4*numii); Xf(:)=sum(tmp2)'; <span class="keyword">end</span>;
0715         Xf=Xf./(ones(4,1)*Xf(4,:));
0716     <span class="comment">%    compute perpendicular directions</span>
0717         pixfact = ((limrange(1,ii)./limrange(2,ii)).*(ap(2,ii)./ap(1,ii))).^2;
0718         pixfact = [pixfact pixfact pixfact pixfact];
0719         pixfact = [pixfact;1./pixfact];
0720         [dummyval,jj] = max(abs(Xf(1:2,:)-X0(1:2,:)));
0721         jj1 = ((1:4)'*ones(1,length(jj))==ones(4,1)*jj);
0722         jj2 = ((1:4)'*ones(1,length(jj))==ones(4,1)*(3-jj));
0723         jj3 = jj1(1:2,:);
0724         Xf(jj1)=Xf(jj1)+(Xf(jj1)-X0(jj1)==0); <span class="comment">%eaj new 2/24/98</span>
0725         Xp = X0;
0726         Xp(jj2) = X0(jj2) + ones(sum(jj2(:)),1);
0727         Xp(jj1) = X0(jj1) - (Xf(jj2)-X0(jj2))./(Xf(jj1)-X0(jj1)) .* pixfact(jj3);
0728     <span class="comment">%    inverse transform the cross points</span>
0729         <span class="keyword">if</span> (oneax), Xp=invT*Xp;
0730         <span class="keyword">else</span>, tmp1=[Xp;Xp;Xp;Xp]; tmp1=invT(:,[ii ii ii ii]).*tmp1;
0731               tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
0732               Xp=zeros(4,4*numii); Xp(:)=sum(tmp2)'; <span class="keyword">end</span>;
0733         Xp=(Xp(1:3,:)./(ones(3,1)*Xp(4,:))).*axr(:,[ii ii ii ii])+axm(:,[ii ii ii ii]);
0734         basecross(:,ii)  = Xp(:,0*numii+(1:numii));
0735         tipcross(:,ii)   = Xp(:,1*numii+(1:numii));
0736         sbasecross(:,ii) = Xp(:,2*numii+(1:numii));
0737         stipcross(:,ii)  = Xp(:,3*numii+(1:numii));
0738 <span class="keyword">end</span>;
0739 
0740 <span class="comment">% compute all points</span>
0741 <span class="comment">%    compute start points</span>
0742     axm11 = [axm axm axm axm axm axm axm axm axm axm axm];
0743     axr11 = [axr axr axr axr axr axr axr axr axr axr axr];
0744     st = [stoppoint tippoint basepoint sbasepoint stippoint startpoint stippoint sbasepoint basepoint tippoint stoppoint];
0745     tmp1 = (st - axm11) ./ axr11;
0746     tmp1 = [tmp1; ones(1,size(tmp1,2))];
0747     <span class="keyword">if</span> (oneax), X0=T*tmp1;
0748     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[T T T T T T T T T T T].*tmp1;
0749           tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
0750           X0=zeros(4,11*narrows); X0(:)=sum(tmp2)'; <span class="keyword">end</span>;
0751     X0=X0./(ones(4,1)*X0(4,:));
0752 <span class="comment">%    compute stop points</span>
0753     tmp1 = ([start tipcross basecross sbasecross stipcross stop stipcross sbasecross basecross tipcross start] <span class="keyword">...</span>
0754          - axm11) ./ axr11;
0755     tmp1 = [tmp1; ones(1,size(tmp1,2))];
0756     <span class="keyword">if</span> (oneax), Xf=T*tmp1;
0757     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[T T T T T T T T T T T].*tmp1;
0758           tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
0759           Xf=zeros(4,11*narrows); Xf(:)=sum(tmp2)'; <span class="keyword">end</span>;
0760     Xf=Xf./(ones(4,1)*Xf(4,:));
0761 <span class="comment">%    compute lengths</span>
0762     len0  = len.*((ends==1)|(ends==3)).*tan(tipangle/180*pi);
0763     slen0 = len.*((ends==2)|(ends==3)).*tan(tipangle/180*pi);
0764     le = [zeros(1,narrows) len0 wid/2 wid/2 slen0 zeros(1,narrows) -slen0 -wid/2 -wid/2 -len0 zeros(1,narrows)];
0765     aprange = ap./limrange;
0766     aprange = [aprange aprange aprange aprange aprange aprange aprange aprange aprange aprange aprange];
0767     D = sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*aprange).^2));
0768     Dii=find(D==0); <span class="keyword">if</span> ~isempty(Dii), D=D+(D==0); le(Dii)=zeros(1,length(Dii)); <span class="keyword">end</span>; <span class="comment">%should fix DivideByZero warnings</span>
0769     tmp1 = X0.*(ones(4,1)*(1-le./D)) + Xf.*(ones(4,1)*(le./D));
0770 <span class="comment">%    inverse transform</span>
0771     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0772     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[invT invT invT invT invT invT invT invT invT invT invT].*tmp1;
0773           tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
0774           tmp3=zeros(4,11*narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0775     pts = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)) .* axr11 + axm11;
0776 
0777 <span class="comment">% correct for ones where the crossdir was specified</span>
0778 ii = find(~(all(crossdir==0)|any(isnan(crossdir))));
0779 <span class="keyword">if</span> ~isempty(ii),
0780     D1 = [pts(:,1*narrows+ii)-pts(:,9*narrows+ii) <span class="keyword">...</span>
0781           pts(:,2*narrows+ii)-pts(:,8*narrows+ii) <span class="keyword">...</span>
0782           pts(:,3*narrows+ii)-pts(:,7*narrows+ii) <span class="keyword">...</span>
0783           pts(:,4*narrows+ii)-pts(:,6*narrows+ii) <span class="keyword">...</span>
0784           pts(:,6*narrows+ii)-pts(:,4*narrows+ii) <span class="keyword">...</span>
0785           pts(:,7*narrows+ii)-pts(:,3*narrows+ii) <span class="keyword">...</span>
0786           pts(:,8*narrows+ii)-pts(:,2*narrows+ii) <span class="keyword">...</span>
0787           pts(:,9*narrows+ii)-pts(:,1*narrows+ii)]/2;
0788     ii = ii'*ones(1,8) + ones(length(ii),1)*[1:4 6:9]*narrows;
0789     ii = ii(:)';
0790     pts(:,ii) = st(:,ii) + D1;
0791 <span class="keyword">end</span>;
0792 
0793 
0794 <span class="comment">% readjust for reverse directions</span>
0795 iicols=(1:narrows)'; iicols=iicols(:,ones(1,11)); iicols=iicols(:).';
0796 tmp1=axrev(:,iicols);
0797 ii = find(tmp1(:)); <span class="keyword">if</span> ~isempty(ii), pts(ii)=-pts(ii); <span class="keyword">end</span>;
0798 
0799 <span class="comment">% readjust for log scale on axes</span>
0800 tmp1=xyzlog(:,iicols);
0801 ii = find(tmp1(:)); <span class="keyword">if</span> ~isempty(ii), pts(ii)=10.^pts(ii); <span class="keyword">end</span>;
0802 
0803 <span class="comment">% compute the x,y,z coordinates of the patches;</span>
0804 ii = narrows*(0:10)'*ones(1,narrows) + ones(11,1)*(1:narrows);
0805 ii = ii(:)';
0806 x = zeros(11,narrows);
0807 y = zeros(11,narrows);
0808 z = zeros(11,narrows);
0809 x(:) = pts(1,ii)';
0810 y(:) = pts(2,ii)';
0811 z(:) = pts(3,ii)';
0812 
0813 <span class="comment">% do the output</span>
0814 <span class="keyword">if</span> (nargout&lt;=1),
0815 <span class="comment">%    % create or modify the patches</span>
0816     newpatch = <a href="#_sub13" class="code" title="subfunction out = trueornan(x)">trueornan</a>(ispatch) &amp; (isempty(oldh)|~strcmp(get(oldh,<span class="string">'Type'</span>),<span class="string">'patch'</span>));
0817     newline = ~<a href="#_sub13" class="code" title="subfunction out = trueornan(x)">trueornan</a>(ispatch) &amp; (isempty(oldh)|~strcmp(get(oldh,<span class="string">'Type'</span>),<span class="string">'line'</span>));
0818     <span class="keyword">if</span> isempty(oldh), H=zeros(narrows,1); <span class="keyword">else</span>, H=oldh; <span class="keyword">end</span>;
0819 <span class="comment">%    % make or modify the arrows</span>
0820     <span class="keyword">for</span> k=1:narrows,
0821         <span class="keyword">if</span> all(isnan(ud(k,[3 6])))&amp;<a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax(k)), zz=[]; <span class="keyword">else</span>, zz=z(:,k); <span class="keyword">end</span>;
0822         xx=x(:,k); yy=y(:,k);
0823         <span class="keyword">if</span> (0), <span class="comment">% this fix didn't work, so let's not use it -- 8/26/03</span>
0824             <span class="comment">% try to work around a MATLAB 6.x OpenGL bug -- 7/28/02</span>
0825               mask=any([ones(1,2+size(zz,2));diff([xx yy zz],[],1)],2);
0826               xx=xx(mask); yy=yy(mask); <span class="keyword">if</span> ~isempty(zz), zz=zz(mask); <span class="keyword">end</span>;
0827         <span class="keyword">end</span>;
0828         <span class="comment">% plot the patch or line</span>
0829         xyz = {<span class="string">'XData'</span>,xx,<span class="string">'YData'</span>,yy,<span class="string">'ZData'</span>,zz,<span class="string">'Tag'</span>,ArrowTag};
0830         <span class="keyword">if</span> newpatch(k)|newline(k),
0831             <span class="keyword">if</span> newpatch(k),
0832                 H(k) = patch(xyz{:});
0833             <span class="keyword">else</span>,
0834                 H(k) = line(xyz{:});
0835             <span class="keyword">end</span>;
0836             <span class="keyword">if</span> ~isempty(oldh), <a href="#_sub12" class="code" title="subfunction arrow_copyprops(fm,to)">arrow_copyprops</a>(oldh(k),H(k)); <span class="keyword">end</span>;
0837         <span class="keyword">else</span>,
0838             <span class="keyword">if</span> ispatch(k), xyz={xyz{:},<span class="string">'CData'</span>,[]}; <span class="keyword">end</span>;
0839             set(H(k),xyz{:});
0840         <span class="keyword">end</span>;
0841     <span class="keyword">end</span>;
0842     <span class="keyword">if</span> ~isempty(oldh), delete(oldh(oldh~=H)); <span class="keyword">end</span>;
0843 <span class="comment">%    % additional properties</span>
0844     set(H,<span class="string">'Clipping'</span>,<span class="string">'off'</span>);
0845     set(H,{<span class="string">'UserData'</span>},num2cell(ud,2));
0846     <span class="keyword">if</span> (length(extraprops)&gt;0), set(H,extraprops{:}); <span class="keyword">end</span>;
0847     <span class="comment">% handle choosing arrow Start and/or Stop locations if unspecified</span>
0848     [H,oldaxlims,errstr] = <a href="#_sub2" class="code" title="subfunction [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)">arrow_clicks</a>(H,ud,x,y,z,ax,oldaxlims);
0849     <span class="keyword">if</span> ~isempty(errstr), error([upper(mfilename) <span class="string">' got '</span> errstr]); <span class="keyword">end</span>;
0850     <span class="comment">% set the output</span>
0851     <span class="keyword">if</span> (nargout&gt;0), h=H; <span class="keyword">end</span>;
0852     <span class="comment">% make sure the axis limits did not change</span>
0853     <span class="keyword">if</span> isempty(oldaxlims),
0854         ARROW_AXLIMITS = [];
0855     <span class="keyword">else</span>,
0856         lims = get(oldaxlims(:,1),{<span class="string">'XLim'</span>,<span class="string">'YLim'</span>,<span class="string">'ZLim'</span>})';
0857         lims = reshape(cat(2,lims{:}),6,size(lims,2));
0858         mask = <a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(oldaxlims(:,1));
0859         oldaxlims(mask,6:7) = lims(5:6,mask)';
0860         ARROW_AXLIMITS = oldaxlims(find(any(oldaxlims(:,2:7)'~=lims)),:);
0861         <span class="keyword">if</span> ~isempty(ARROW_AXLIMITS),
0862             warning(<a href="#_sub11" class="code" title="subfunction out = arrow_warnlimits(axlimits,narrows)">arrow_warnlimits</a>(ARROW_AXLIMITS,narrows));
0863         <span class="keyword">end</span>;
0864     <span class="keyword">end</span>;
0865 <span class="keyword">else</span>,
0866     <span class="comment">% don't create the patch, just return the data</span>
0867     h=x;
0868     yy=y;
0869     zz=z;
0870 <span class="keyword">end</span>;
0871 
0872 
0873 
0874 <a name="_sub1" href="#_subfunctions" class="code">function out = arrow_defcheck(in,def,prop)</a>
0875 <span class="comment">% check if we got 'default' values</span>
0876     out = in;
0877     <span class="keyword">if</span> ~isstr(in), <span class="keyword">return</span>; <span class="keyword">end</span>;
0878     <span class="keyword">if</span> size(in,1)==1 &amp; strncmp(lower(in),<span class="string">'def'</span>,3),
0879         out = def;
0880     <span class="keyword">elseif</span> ~isempty(prop),
0881         error([upper(mfilename) <span class="string">' does not recognize '''</span> in(:)' <span class="string">''' as a valid '''</span> prop <span class="string">''' string.'</span>]);
0882     <span class="keyword">end</span>;
0883 
0884 
0885 
0886 <a name="_sub2" href="#_subfunctions" class="code">function [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)</a>
0887 <span class="comment">% handle choosing arrow Start and/or Stop locations if necessary</span>
0888     errstr = <span class="string">''</span>;
0889     <span class="keyword">if</span> isempty(H)|isempty(ud)|isempty(x), <span class="keyword">return</span>; <span class="keyword">end</span>;
0890     <span class="comment">% determine which (if any) need Start and/or Stop</span>
0891     needStart = all(isnan(ud(:,1:3)'))';
0892     needStop  = all(isnan(ud(:,4:6)'))';
0893     mask = any(needStart|needStop);
0894     <span class="keyword">if</span> ~any(mask), <span class="keyword">return</span>; <span class="keyword">end</span>;
0895     ud(~mask,:)=[]; ax(:,~mask)=[];
0896     x(:,~mask)=[]; y(:,~mask)=[]; z(:,~mask)=[];
0897     <span class="comment">% make them invisible for the time being</span>
0898     set(H,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0899     <span class="comment">% save the current axes and limits modes; set to manual for the time being</span>
0900     oldAx  = gca;
0901     limModes=get(ax(:),{<span class="string">'XLimMode'</span>,<span class="string">'YLimMode'</span>,<span class="string">'ZLimMode'</span>});
0902     set(ax(:),{<span class="string">'XLimMode'</span>,<span class="string">'YLimMode'</span>,<span class="string">'ZLimMode'</span>},{<span class="string">'manual'</span>,<span class="string">'manual'</span>,<span class="string">'manual'</span>});
0903     <span class="comment">% loop over each arrow that requires attention</span>
0904     jj = find(mask);
0905     <span class="keyword">for</span> ii=1:length(jj),
0906         h = H(jj(ii));
0907         axes(ax(ii));
0908         <span class="comment">% figure out correct call</span>
0909         <span class="keyword">if</span> needStart(ii), prop=<span class="string">'Start'</span>; <span class="keyword">else</span>, prop=<span class="string">'Stop'</span>; <span class="keyword">end</span>;
0910         [wasInterrupted,errstr] = <a href="#_sub3" class="code" title="subfunction [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)">arrow_click</a>(needStart(ii)&amp;needStop(ii),h,prop,ax(ii));
0911         <span class="comment">% handle errors and control-C</span>
0912         <span class="keyword">if</span> wasInterrupted,
0913             delete(H(jj(ii:end)));
0914             H(jj(ii:end))=[];
0915             oldaxlims(jj(ii:end),:)=[];
0916             <span class="keyword">break</span>;
0917         <span class="keyword">end</span>;
0918     <span class="keyword">end</span>;
0919     <span class="comment">% restore the axes and limit modes</span>
0920     axes(oldAx);
0921     set(ax(:),{<span class="string">'XLimMode'</span>,<span class="string">'YLimMode'</span>,<span class="string">'ZLimMode'</span>},limModes);
0922 
0923 <a name="_sub3" href="#_subfunctions" class="code">function [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)</a>
0924 <span class="comment">% handle the clicks for one arrow</span>
0925     fig = get(ax,<span class="string">'Parent'</span>);
0926     <span class="comment">% save some things</span>
0927     oldFigProps = {<span class="string">'Pointer'</span>,<span class="string">'WindowButtonMotionFcn'</span>,<span class="string">'WindowButtonUpFcn'</span>};
0928     oldFigValue = get(fig,oldFigProps);
0929     oldArrowProps = {<span class="string">'EraseMode'</span>};
0930     oldArrowValue = get(H,oldArrowProps);
0931     set(H,<span class="string">'EraseMode'</span>,<span class="string">'background'</span>); <span class="comment">%because 'xor' makes shaft invisible unless Width&gt;1</span>
0932     <span class="keyword">global</span> ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
0933     ARROW_CLICK_H=H; ARROW_CLICK_PROP=prop; ARROW_CLICK_AX=ax;
0934     ARROW_CLICK_USE_Z=~<a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax)|~<a href="#_sub8" class="code" title="subfunction out = arrow_planarkids(ax)">arrow_planarkids</a>(ax);
0935     set(fig,<span class="string">'Pointer'</span>,<span class="string">'crosshair'</span>);
0936     <span class="comment">% set up the WindowButtonMotion so we can see the arrow while moving around</span>
0937     set(fig,<span class="string">'WindowButtonUpFcn'</span>,<span class="string">'set(gcf,''WindowButtonUpFcn'','''')'</span>, <span class="keyword">...</span>
0938             <span class="string">'WindowButtonMotionFcn'</span>,<span class="string">''</span>);
0939     <span class="keyword">if</span> ~lockStart,
0940         set(H,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0941         set(fig,<span class="string">'WindowButtonMotionFcn'</span>,[mfilename <span class="string">'(''callback'',''motion'');'</span>]);
0942     <span class="keyword">end</span>;
0943     <span class="comment">% wait for the button to be pressed</span>
0944     [wasKeyPress,wasInterrupted,errstr] = <a href="#_sub6" class="code" title="subfunction [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)">arrow_wfbdown</a>(fig);
0945     <span class="comment">% if we wanted to click-drag, set the Start point</span>
0946     <span class="keyword">if</span> lockStart &amp; ~wasInterrupted,
0947         pt = <a href="#_sub5" class="code" title="subfunction out = arrow_point(ax,use_z)">arrow_point</a>(ARROW_CLICK_AX,ARROW_CLICK_USE_Z);
0948         feval(mfilename,H,<span class="string">'Start'</span>,pt,<span class="string">'Stop'</span>,pt);
0949         set(H,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0950         ARROW_CLICK_PROP=<span class="string">'Stop'</span>;
0951         set(fig,<span class="string">'WindowButtonMotionFcn'</span>,[mfilename <span class="string">'(''callback'',''motion'');'</span>]);
0952         <span class="comment">% wait for the mouse button to be released</span>
0953         <span class="keyword">try</span>
0954             waitfor(fig,<span class="string">'WindowButtonUpFcn'</span>,<span class="string">''</span>);
0955         <span class="keyword">catch</span>
0956             errstr = lasterr;
0957             wasInterrupted = 1;
0958         <span class="keyword">end</span>;
0959     <span class="keyword">end</span>;
0960     <span class="keyword">if</span> ~wasInterrupted, feval(mfilename,<span class="string">'callback'</span>,<span class="string">'motion'</span>); <span class="keyword">end</span>;
0961     <span class="comment">% restore some things</span>
0962     set(gcf,oldFigProps,oldFigValue);
0963     set(H,oldArrowProps,oldArrowValue);
0964 
0965 <a name="_sub4" href="#_subfunctions" class="code">function arrow_callback(varargin)</a>
0966 <span class="comment">% handle redrawing callbacks</span>
0967     <span class="keyword">if</span> nargin==0, <span class="keyword">return</span>; <span class="keyword">end</span>;
0968     str = varargin{1};
0969     <span class="keyword">if</span> ~isstr(str), error([upper(mfilename) <span class="string">' got an invalid Callback command.'</span>]); <span class="keyword">end</span>;
0970     s = lower(str);
0971     <span class="keyword">if</span> strcmp(s,<span class="string">'motion'</span>),
0972         <span class="comment">% motion callback</span>
0973         <span class="keyword">global</span> ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
0974         feval(mfilename,ARROW_CLICK_H,ARROW_CLICK_PROP,<a href="#_sub5" class="code" title="subfunction out = arrow_point(ax,use_z)">arrow_point</a>(ARROW_CLICK_AX,ARROW_CLICK_USE_Z));
0975         drawnow;
0976     <span class="keyword">else</span>,
0977         error([upper(mfilename) <span class="string">' does not recognize '''</span> str(:).' <span class="string">''' as a valid Callback option.'</span>]);
0978     <span class="keyword">end</span>;
0979 
0980 <a name="_sub5" href="#_subfunctions" class="code">function out = arrow_point(ax,use_z)</a>
0981 <span class="comment">% return the point on the given axes</span>
0982     <span class="keyword">if</span> nargin==0, ax=gca; <span class="keyword">end</span>;
0983     <span class="keyword">if</span> nargin&lt;2, use_z=~<a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax)|~<a href="#_sub8" class="code" title="subfunction out = arrow_planarkids(ax)">arrow_planarkids</a>(ax); <span class="keyword">end</span>;
0984     out = get(ax,<span class="string">'CurrentPoint'</span>);
0985     out = out(1,:);
0986     <span class="keyword">if</span> ~use_z, out=out(1:2); <span class="keyword">end</span>;
0987 
0988 <a name="_sub6" href="#_subfunctions" class="code">function [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)</a>
0989 <span class="comment">% wait for button down ignoring object ButtonDownFcn's</span>
0990     <span class="keyword">if</span> nargin==0, fig=gcf; <span class="keyword">end</span>;
0991     errstr = <span class="string">''</span>;
0992     <span class="comment">% save ButtonDownFcn values</span>
0993     objs = findobj(fig);
0994     buttonDownFcns = get(objs,<span class="string">'ButtonDownFcn'</span>);
0995     mask=~strcmp(buttonDownFcns,<span class="string">''</span>); objs=objs(mask); buttonDownFcns=buttonDownFcns(mask);
0996     set(objs,<span class="string">'ButtonDownFcn'</span>,<span class="string">''</span>);
0997     <span class="comment">% save other figure values</span>
0998     figProps = {<span class="string">'KeyPressFcn'</span>,<span class="string">'WindowButtonDownFcn'</span>};
0999     figValue = get(fig,figProps);
1000     <span class="comment">% do the real work</span>
1001     set(fig,<span class="string">'KeyPressFcn'</span>,<span class="string">'set(gcf,''KeyPressFcn'','''',''WindowButtonDownFcn'','''');'</span>, <span class="keyword">...</span>
1002             <span class="string">'WindowButtonDownFcn'</span>,<span class="string">'set(gcf,''WindowButtonDownFcn'','''')'</span>);
1003     lasterr(<span class="string">''</span>);
1004     <span class="keyword">try</span>
1005         waitfor(fig,<span class="string">'WindowButtonDownFcn'</span>,<span class="string">''</span>);
1006         wasInterrupted = 0;
1007     <span class="keyword">catch</span>
1008         wasInterrupted = 1;
1009     <span class="keyword">end</span>
1010     wasKeyPress = ~wasInterrupted &amp; strcmp(get(fig,<span class="string">'KeyPressFcn'</span>),<span class="string">''</span>);
1011     <span class="keyword">if</span> wasInterrupted, errstr=lasterr; <span class="keyword">end</span>;
1012     <span class="comment">% restore ButtonDownFcn and other figure values</span>
1013     set(objs,<span class="string">'ButtonDownFcn'</span>,buttonDownFcns);
1014     set(fig,figProps,figValue);
1015 
1016 
1017 
1018 <a name="_sub7" href="#_subfunctions" class="code">function [out,is2D] = arrow_is2DXY(ax)</a>
1019 <span class="comment">% check if axes are 2-D X-Y plots</span>
1020     <span class="comment">% may not work for modified camera angles, etc.</span>
1021     out = logical(zeros(size(ax))); <span class="comment">% 2-D X-Y plots</span>
1022     is2D = out;                     <span class="comment">% any 2-D plots</span>
1023     views = get(ax(:),{<span class="string">'View'</span>});
1024     views = cat(1,views{:});
1025     out(:) = abs(views(:,2))==90;
1026     is2D(:) = out(:) | all(rem(views',90)==0)';
1027 
1028 <a name="_sub8" href="#_subfunctions" class="code">function out = arrow_planarkids(ax)</a>
1029 <span class="comment">% check if axes descendents all have empty ZData (lines,patches,surfaces)</span>
1030     out = logical(ones(size(ax)));
1031     allkids = get(ax(:),{<span class="string">'Children'</span>});
1032     <span class="keyword">for</span> k=1:length(allkids),
1033         kids = get([findobj(allkids{k},<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'line'</span>)
1034                     findobj(allkids{k},<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'patch'</span>)
1035                     findobj(allkids{k},<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'surface'</span>)],{<span class="string">'ZData'</span>});
1036         <span class="keyword">for</span> j=1:length(kids),
1037             <span class="keyword">if</span> ~isempty(kids{j}), out(k)=logical(0); <span class="keyword">break</span>; <span class="keyword">end</span>;
1038         <span class="keyword">end</span>;
1039     <span class="keyword">end</span>;
1040 
1041 
1042 
1043 <a name="_sub9" href="#_subfunctions" class="code">function arrow_fixlimits(axlimits)</a>
1044 <span class="comment">% reset the axis limits as necessary</span>
1045     <span class="keyword">if</span> isempty(axlimits), disp([upper(mfilename) <span class="string">' does not remember any axis limits to reset.'</span>]); <span class="keyword">end</span>;
1046     <span class="keyword">for</span> k=1:size(axlimits,1),
1047         <span class="keyword">if</span> any(get(axlimits(k,1),<span class="string">'XLim'</span>)~=axlimits(k,2:3)), set(axlimits(k,1),<span class="string">'XLim'</span>,axlimits(k,2:3)); <span class="keyword">end</span>;
1048         <span class="keyword">if</span> any(get(axlimits(k,1),<span class="string">'YLim'</span>)~=axlimits(k,4:5)), set(axlimits(k,1),<span class="string">'YLim'</span>,axlimits(k,4:5)); <span class="keyword">end</span>;
1049         <span class="keyword">if</span> any(get(axlimits(k,1),<span class="string">'ZLim'</span>)~=axlimits(k,6:7)), set(axlimits(k,1),<span class="string">'ZLim'</span>,axlimits(k,6:7)); <span class="keyword">end</span>;
1050     <span class="keyword">end</span>;
1051 
1052 
1053 
1054 <a name="_sub10" href="#_subfunctions" class="code">function out = arrow_WarpToFill(notstretched,manualcamera,curax)</a>
1055 <span class="comment">% check if we are in &quot;WarpToFill&quot; mode.</span>
1056     out = strcmp(get(curax,<span class="string">'WarpToFill'</span>),<span class="string">'on'</span>);
1057     <span class="comment">% 'WarpToFill' is undocumented, so may need to replace this by</span>
1058     <span class="comment">% out = ~( any(notstretched) &amp; any(manualcamera) );</span>
1059 
1060 
1061 
1062 <a name="_sub11" href="#_subfunctions" class="code">function out = arrow_warnlimits(axlimits,narrows)</a>
1063 <span class="comment">% create a warning message if we've changed the axis limits</span>
1064     msg = <span class="string">''</span>;
1065     <span class="keyword">switch</span> (size(axlimits,1))
1066         <span class="keyword">case</span> 1, msg=<span class="string">''</span>;
1067         <span class="keyword">case</span> 2, msg=<span class="string">'on two axes '</span>;
1068         <span class="keyword">otherwise</span>, msg=<span class="string">'on several axes '</span>;
1069     <span class="keyword">end</span>;
1070     msg = [upper(mfilename) <span class="string">' changed the axis limits '</span> msg <span class="keyword">...</span>
1071            <span class="string">'when adding the arrow'</span>];
1072     <span class="keyword">if</span> (narrows&gt;1), msg=[msg <span class="string">'s'</span>]; <span class="keyword">end</span>;
1073     out = [msg <span class="string">'.'</span> sprintf(<span class="string">'\n'</span>) <span class="string">'         Call '</span> upper(mfilename) <span class="keyword">...</span>
1074            <span class="string">' FIXLIMITS to reset them now.'</span>];
1075 
1076 
1077 
1078 <a name="_sub12" href="#_subfunctions" class="code">function arrow_copyprops(fm,to)</a>
1079 <span class="comment">% copy line properties to patches</span>
1080     props  = {<span class="string">'EraseMode'</span>,<span class="string">'LineStyle'</span>,<span class="string">'LineWidth'</span>,<span class="string">'Marker'</span>,<span class="string">'MarkerSize'</span>,<span class="keyword">...</span>
1081               <span class="string">'MarkerEdgeColor'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'ButtonDownFcn'</span>,      <span class="keyword">...</span>
1082               <span class="string">'Clipping'</span>,<span class="string">'DeleteFcn'</span>,<span class="string">'BusyAction'</span>,<span class="string">'HandleVisibility'</span>,   <span class="keyword">...</span>
1083               <span class="string">'Selected'</span>,<span class="string">'SelectionHighlight'</span>,<span class="string">'Visible'</span>};
1084     lineprops  = {<span class="string">'Color'</span>,    props{:}};
1085     patchprops = {<span class="string">'EdgeColor'</span>,props{:}};
1086     patch2props = {<span class="string">'FaceColor'</span>,patchprops{:}};
1087     fmpatch = strcmp(get(fm,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
1088     topatch = strcmp(get(to,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
1089     set(to( fmpatch&amp; topatch),patch2props,get(fm( fmpatch&amp; topatch),patch2props)); <span class="comment">%p-&gt;p</span>
1090     set(to(~fmpatch&amp;~topatch),lineprops,  get(fm(~fmpatch&amp;~topatch),lineprops  )); <span class="comment">%l-&gt;l</span>
1091     set(to( fmpatch&amp;~topatch),lineprops,  get(fm( fmpatch&amp;~topatch),patchprops )); <span class="comment">%p-&gt;l</span>
1092     set(to(~fmpatch&amp; topatch),patchprops, get(fm(~fmpatch&amp; topatch),lineprops)  ,<span class="string">'FaceColor'</span>,<span class="string">'none'</span>); <span class="comment">%l-&gt;p</span>
1093 
1094 
1095 <a name="_sub13" href="#_subfunctions" class="code">function out = trueornan(x)</a>
1096 <span class="keyword">if</span> isempty(x),
1097     out=x;
1098 <span class="keyword">else</span>,
1099     out = isnan(x);
1100     out(~out) = x(~out);
1101 <span class="keyword">end</span>;</pre></div>
<hr><address>Generated on Thu 25-Oct-2012 18:03:26 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>