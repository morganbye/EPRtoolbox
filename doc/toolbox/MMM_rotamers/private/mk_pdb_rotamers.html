<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_pdb_rotamers</title>
  <meta name="keywords" content="mk_pdb_rotamers">
  <meta name="description" content="Transforms rotamer coordinates from the native frame in which they are">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">toolbox</a> &gt; <a href="../index.html">MMM_rotamers</a> &gt; <a href="index.html">private</a> &gt; mk_pdb_rotamers.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for toolbox/MMM_rotamers/private&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>mk_pdb_rotamers
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Transforms rotamer coordinates from the native frame in which they are</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function calc_positions=mk_pdb_rotamers(allindices,rot_lib,T,no_compute,stat_file,PDB_path,library) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Transforms rotamer coordinates from the native frame in which they are 
 stored in the library into frame of attachment assiciated with 
 the selected sites. Returns separated pdb files for each rotamer.

 no_compute        optional flag that requests to return only pre-computed
                   rotamers, defaults to false
 PDB_path          optional path for individual rotamer PDB files
 library           optional name of rotamer library</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="get_transformed_rotamers.html" class="code" title="function [rotamers_stats,msg]=get_transformed_rotamers(coor,site,calc_opt,rot_lib)">get_transformed_rotamers</a>	function [rotamers_stats,msg]=get_rotamers_transformed(coor,site,calc_opt,rot_lib);</li><li><a href="wr_sep_rot_pdb.html" class="code" title="function wr_sep_rot_pdb(input)">wr_sep_rot_pdb</a>	funtion wr_sep_rot_pdb() writes pdb separate pdb files for each rotamer</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="transform_rotamers.html" class="code" title="function msg=transform_rotamers(indices)">transform_rotamers</a>	for selected sites in the protein structure (or model), initilize</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [ecoor,offset]=ecoor_structure(indices,waterflag)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function calc_positions=mk_pdb_rotamers(allindices,rot_lib,T,no_compute,stat_file,PDB_path,library)</a>
0002 <span class="comment">% Transforms rotamer coordinates from the native frame in which they are</span>
0003 <span class="comment">% stored in the library into frame of attachment assiciated with</span>
0004 <span class="comment">% the selected sites. Returns separated pdb files for each rotamer.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% no_compute        optional flag that requests to return only pre-computed</span>
0007 <span class="comment">%                   rotamers, defaults to false</span>
0008 <span class="comment">% PDB_path          optional path for individual rotamer PDB files</span>
0009 <span class="comment">% library           optional name of rotamer library</span>
0010 <span class="comment">%</span>
0011 
0012 
0013 <span class="comment">% Ye. Polyhach 2011</span>
0014 
0015 <span class="keyword">global</span> hMain
0016 <span class="keyword">global</span> model
0017 
0018 
0019 <span class="keyword">if</span> nargin&lt;4, no_compute=false; <span class="keyword">end</span>;
0020 
0021 <span class="keyword">if</span> nargin&lt;5 || stat_file==-1, hMain.statistics=0; <span class="keyword">end</span>;
0022 
0023 <span class="keyword">if</span> nargin&lt;6, PDB_path=<span class="string">''</span>; <span class="keyword">end</span>;
0024     
0025 <span class="keyword">if</span> nargin&lt;7, library=<span class="string">'UNKNOWN'</span>; <span class="keyword">end</span>;
0026 
0027 threshold=0.005; <span class="comment">% 0.5% of population is neglected</span>
0028 
0029 consider_water=false; <span class="comment">% flag for also considering water collisions, should</span>
0030                       <span class="comment">% be true only for comparison with old computations</span>
0031                       <span class="comment">% or for testing</span>
0032 
0033 msg.error=0;
0034 msg.text=<span class="string">''</span>;
0035 
0036 calc_opt.ext_potential=<span class="string">'charmm27'</span>; <span class="comment">% default are charmm27 Lennard-Jones energies</span>
0037 calc_opt.forgive=0.5;
0038 
0039 <span class="keyword">if</span> nargin&gt;2,
0040     calc_opt.T=T; <span class="comment">% set target temperature, if given</span>
0041 <span class="keyword">else</span>
0042     T=rot_lib.calibration.T;
0043     calc_opt.T=T;
0044 <span class="keyword">end</span>;
0045 
0046 calc_positions=[]; <span class="comment">% initialize empty output array</span>
0047 
0048 stags=model.structure_tags;
0049 stags=stags(2:end); <span class="comment">% remove leading delimiter</span>
0050 nonsense=textscan(stags,<span class="string">'%s'</span>,<span class="string">'Delimiter'</span>,<span class="string">':'</span>);
0051 stag_list=nonsense{1};
0052 
0053 respoi=0; <span class="comment">% pointer for successfully labeled residues</span>
0054 [mres,nres]=size(allindices);
0055 add_msg_board(sprintf(<span class="string">'Rotamer coordinate transformation for %i selected object(s).'</span>,mres));
0056 msgpoi=1;
0057 <span class="keyword">for</span> kres=1:mres, <span class="comment">% loop over all objects</span>
0058     cindices=allindices(kres,:);
0059     cindices=cindices(cindices&gt;0); <span class="comment">% cut zero indices</span>
0060     <span class="keyword">if</span> length(cindices)==4, <span class="comment">% consider only residue indices</span>
0061         computed=0;
0062         <span class="keyword">if</span> isfield(model,<span class="string">'sites'</span>),
0063             <span class="keyword">for</span> ks=1:length(model.sites),
0064                 <span class="keyword">for</span> kc=1:length(model.sites{ks}),
0065                     <span class="keyword">for</span> kr=1:length(model.sites{ks}(kc).residue),
0066                         eindices=model.sites{ks}(kc).residue(kr).indices;
0067                         <span class="keyword">if</span> cindices==eindices,
0068                             <span class="comment">% this residue was already computed in a site scan</span>
0069                             <span class="keyword">if</span> abs(T-model.sites{ks}(kc).residue(kr).T)&lt;1 &amp;&amp; strcmp(model.sites{ks}(kc).residue(kr).label,rot_lib.label),
0070                                 computed=1;
0071                                 my_rotamers=model.sites{ks}(kc).residue(kr);
0072                             <span class="keyword">end</span>;
0073                         <span class="keyword">end</span>;
0074                     <span class="keyword">end</span>;
0075                 <span class="keyword">end</span>;
0076             <span class="keyword">end</span>;
0077         <span class="keyword">end</span>;
0078         <span class="keyword">if</span> ~computed, <span class="comment">% compute only residues that were not previously computed in a site scan</span>
0079             name=model.structures{cindices(1)}(cindices(2)).residues{cindices(3)}.info(cindices(4)).name;
0080             <span class="keyword">if</span> strcmpi(name,<span class="string">'R1A'</span>) || strcmpi(name,<span class="string">'IA1'</span>),
0081                 resadr=mk_address(cindices);
0082                 add_msg_board(sprintf(<span class="string">'WARNING: Residue %s was already spin labeled with label %s'</span>,resadr,name));
0083             <span class="keyword">end</span>;
0084             <span class="keyword">if</span> no_compute,
0085                 resadr=mk_address(cindices);
0086                 potentials=[];
0087                 msg.error=13;
0088                 msg.text=sprintf(<span class="string">'Warning: Rotamers of %s were not previously computed. Please use EPR/Site scan menu item for rotamer computation.'</span>,resadr);
0089             <span class="keyword">else</span>
0090                 <span class="comment">% get extended coordinates of the whole structure where the labeled</span>
0091                 <span class="comment">% residue is</span>
0092                 [coor,offset]=<a href="#_sub1" class="code" title="subfunction [ecoor,offset]=ecoor_structure(indices,waterflag)">ecoor_structure</a>(cindices,consider_water);
0093                 <span class="comment">% get all atom indices of the residue into the MMM object structure</span>
0094                 [msg,indices]=get_object(cindices,<span class="string">'children'</span>);
0095                 [m,n]=size(indices);
0096                 index_array=zeros(5*m,1);
0097                 poi=0;
0098                 <span class="comment">% convert to the atom indices into the extended coordinate array,</span>
0099                 <span class="comment">% considering all locations</span>
0100                 <span class="keyword">for</span> k=1:m,
0101                     [msg,numbers]=get_atom(indices(k,:),<span class="string">'numbers'</span>);
0102                     [mm,nn]=size(numbers);
0103                     index_array(poi+1:poi+mm)=numbers(:,1)+offset;
0104                     poi=poi+mm;
0105                 <span class="keyword">end</span>;
0106                 site.res_atoms=index_array(1:poi);
0107                 <span class="comment">% get the backbone atom indices for superposition of label with</span>
0108                 <span class="comment">% backbone</span>
0109                 resadr=mk_address(cindices); <span class="comment">% MMM address of current residue</span>
0110 
0111                 adr=sprintf(<span class="string">'%s.N'</span>,resadr);
0112                 [msg,N]=get_object(adr,<span class="string">'numbers'</span>);
0113                 <span class="keyword">if</span> isempty(N),
0114                     add_msg_board(sprintf(<span class="string">'Residue %s is not an amino acid. Not labeled.'</span>,resadr));
0115                     <span class="keyword">continue</span>;
0116                 <span class="keyword">end</span>;
0117                 site.N=N(1,1)+offset;
0118 
0119                 adr=sprintf(<span class="string">'%s.C'</span>,resadr);
0120                 [msg,C]=get_object(adr,<span class="string">'numbers'</span>);
0121                 <span class="keyword">if</span> isempty(C),
0122                     add_msg_board(sprintf(<span class="string">'Residue %s is not an amino acid. Not labeled.'</span>,resadr));
0123                     <span class="keyword">continue</span>;
0124                 <span class="keyword">end</span>;
0125                 site.C=C(1,1)+offset;
0126 
0127                 adr=sprintf(<span class="string">'%s.CA'</span>,resadr);
0128                 [msg,CA]=get_object(adr,<span class="string">'numbers'</span>);
0129                 <span class="keyword">if</span> isempty(CA),
0130                     add_msg_board(sprintf(<span class="string">'Residue %s is not an amino acid. Not labeled.'</span>,resadr));
0131                     <span class="keyword">continue</span>;
0132                 <span class="keyword">end</span>;
0133                 site.CA=CA(1,1)+offset;
0134 
0135                 add_msg_board(sprintf(<span class="string">'Transforming rotamer coordinates for residue %s'</span>,resadr));
0136                 add_msg_board(sprintf(<span class="string">'with label %s at a temperature of %4.0f K'</span>,rot_lib.label,T));
0137                 set(hMain.figure,<span class="string">'Pointer'</span>,<span class="string">'watch'</span>);
0138                 drawnow;
0139                 
0140 <span class="comment">% from 24012011: adding return transformed rotamers:</span>
0141 <span class="comment">%                 [rotamers_stats,msg]=get_rotamers(coor,site,calc_opt,rot_lib);</span>
0142 
0143                 [rotamers_stats,msg]=<a href="get_transformed_rotamers.html" class="code" title="function [rotamers_stats,msg]=get_transformed_rotamers(coor,site,calc_opt,rot_lib)">get_transformed_rotamers</a>(coor,site,calc_opt,rot_lib);
0144                 rot_out_name=strcat(PDB_path,<span class="string">'/rotamers'</span>);
0145                 mkdir(rot_out_name);
0146                 rot_out_name=strcat(rot_out_name,<span class="string">'/'</span>,resadr,<span class="string">'_'</span>,library,<span class="string">'_rot_'</span>);
0147                 
0148                 rotamers_stats.save_name=rot_out_name;
0149                 rotamers_stats.connect=rot_lib.connect;
0150                 <a href="wr_sep_rot_pdb.html" class="code" title="function wr_sep_rot_pdb(input)">wr_sep_rot_pdb</a>(rotamers_stats);
0151 
0152                 add_msg_board(msg.text);
0153                 add_msg_board(<span class="string">'....... '</span>);
0154 <span class="comment">%                 potentials=rotamers_stats.all_potentials;</span>
0155 <span class="comment">%                 if hMain.statistics &amp;&amp; ~isempty(potentials) &amp;&amp; sum(potentials.pop_rot)&gt;=1e-6,</span>
0156 <span class="comment">%                     wr_rotamer_statistics(stat_file,resadr,rot_lib.calibration.T,rotamers_stats,threshold,calc_opt.T,calc_opt.forgive,rot_lib.label);</span>
0157 <span class="comment">%                     if hMain.rotamer_PDB,</span>
0158 <span class="comment">%                         mydir=pwd;</span>
0159 <span class="comment">%                         if ~isempty(PDB_path),</span>
0160 <span class="comment">%                             cd(PDB_path);</span>
0161 <span class="comment">%                         end;</span>
0162 <span class="comment">%                         wr_rotamer_pdb(resadr,rotamers_stats,T,rot_lib.label,rot_lib.MD2PDB,library)</span>
0163 <span class="comment">%                         cd(mydir);</span>
0164 <span class="comment">%                     end;</span>
0165 <span class="comment">%                 end;</span>
0166             <span class="keyword">end</span>;
0167         <span class="keyword">else</span>
0168             resadr=mk_address(cindices);
0169             add_msg_board(sprintf(<span class="string">'Rotamers of %s previously computed in site scan.'</span>,resadr));
0170 <span class="comment">%             potentials=my_rotamers.potentials;</span>
0171         <span class="keyword">end</span>;
0172 
0173 <span class="comment">%         if isempty(potentials),</span>
0174 <span class="comment">%             add_msg_board(msg.text);</span>
0175 <span class="comment">%             add_msg_board(sprintf('Rotamer potentials are missing. Residue %s not labeled.',resadr));</span>
0176 <span class="comment">%             set(hMain.figure,'Pointer','arrow');</span>
0177 <span class="comment">%             drawnow;</span>
0178 <span class="comment">%         elseif sum(potentials.pop_rot)&lt;1e-6,</span>
0179 <span class="comment">%             add_msg_board(msg.text);</span>
0180 <span class="comment">%             add_msg_board(sprintf('### Warning ### All populations are zero. Residue %s not labeled.',resadr));</span>
0181 <span class="comment">%             set(hMain.figure,'Pointer','arrow');</span>
0182 <span class="comment">%             drawnow;</span>
0183 <span class="comment">%         else</span>
0184 <span class="comment">%             respoi=respoi+1; % one more residue successfully labeled</span>
0185 <span class="comment">%             if ~computed,</span>
0186 <span class="comment">%                 calc_positions(respoi).label=rot_lib.label;</span>
0187 <span class="comment">%                 calc_positions(respoi).indices=cindices;</span>
0188 <span class="comment">%                 calc_positions(respoi).NOpos=rotamers_stats.NOall;</span>
0189 <span class="comment">%                 calc_positions(respoi).partition_function=rotamers_stats.all_potentials.partition_function;</span>
0190 <span class="comment">%                 calc_positions(respoi).T=T;</span>
0191 <span class="comment">%                 calc_positions(respoi).potentials=potentials;</span>
0192 <span class="comment">%                 [populations,rotamer_numbers]=sort(potentials.pop_rot,2,'descend');</span>
0193 <span class="comment">%                 cumul=cumsum(populations);</span>
0194 <span class="comment">%                 rotnum=length(cumul(cumul&lt;1-threshold))+1;</span>
0195 <span class="comment">%                 % for debugging</span>
0196 <span class="comment">%                 %     figure(1); clf;</span>
0197 <span class="comment">%                 %     plot(populations,'k.');</span>
0198 <span class="comment">%                 %     hold on;</span>
0199 <span class="comment">%                 %     plot(cumul,'r');</span>
0200 <span class="comment">%                 %     plot([rotnum,rotnum],[0,1],'g:');</span>
0201 <span class="comment">%                 pop=rotamers_stats.NOall(:,4);</span>
0202 <span class="comment">%                 pop=pop/sum(pop);</span>
0203 <span class="comment">%                 xmean=sum(rotamers_stats.NOall(:,1).*pop);</span>
0204 <span class="comment">%                 ymean=sum(rotamers_stats.NOall(:,2).*pop);</span>
0205 <span class="comment">%                 zmean=sum(rotamers_stats.NOall(:,3).*pop);</span>
0206 <span class="comment">%                 dx=(rotamers_stats.NOall(:,1)-xmean);</span>
0207 <span class="comment">%                 dy=(rotamers_stats.NOall(:,2)-ymean);</span>
0208 <span class="comment">%                 dz=(rotamers_stats.NOall(:,3)-zmean);</span>
0209 <span class="comment">%                 nNO=length(dx);</span>
0210 <span class="comment">%                 rmsd=sqrt(nNO*sum(dx.^2.*pop+dy.^2.*pop+dz.^2.*pop)/(nNO-1));</span>
0211 <span class="comment">%                 add_msg_board(sprintf('Standard deviation of label position: %4.1f �,rmsd));</span>
0212 <span class="comment">%                 add_msg_board(sprintf('%i rotamer(s) cover(s) %3.1f%% of all population',rotnum,100*(1-threshold)));</span>
0213 <span class="comment">%                 add_msg_board(sprintf('%i out of %i objects completed',kres,mres));</span>
0214 <span class="comment">%                 drawnow;</span>
0215 <span class="comment">%                 rotamer_numbers=rotamer_numbers(1:rotnum);</span>
0216 <span class="comment">%                 populations=populations(1:rotnum);</span>
0217 <span class="comment">%                 populations=populations/sum(populations); % renormalization of populations</span>
0218 <span class="comment">%</span>
0219 <span class="comment">%                 for rotamer=1:length(rotamer_numbers),</span>
0220 <span class="comment">%                     ecoor=rot_lib.library(rotamer_numbers(rotamer)).ecoor;</span>
0221 <span class="comment">%                     [mm,nn]=size(ecoor);</span>
0222 <span class="comment">%                     coor=zeros(length(rot_lib.MD2PDB),3);</span>
0223 <span class="comment">%                     for kk=1:length(rot_lib.MD2PDB),</span>
0224 <span class="comment">%                         if rot_lib.MD2PDB(kk)&gt;0 &amp;&amp; rot_lib.MD2PDB(kk)&lt;=mm,</span>
0225 <span class="comment">%                             coor(kk,:)=ecoor(rot_lib.MD2PDB(kk),2:4);</span>
0226 <span class="comment">%                         else</span>
0227 <span class="comment">%                             coor(kk,:)=[NaN,NaN,NaN];</span>
0228 <span class="comment">%                         end;</span>
0229 <span class="comment">%                     end;</span>
0230 <span class="comment">%                     calc_positions(respoi).rotamers(rotamer).coor=coor;</span>
0231 <span class="comment">%                     calc_positions(respoi).rotamers(rotamer).pop=populations(rotamer);</span>
0232 <span class="comment">%                 end;</span>
0233 <span class="comment">%             else</span>
0234 <span class="comment">%                 calc_positions(respoi).label=my_rotamers.label;</span>
0235 <span class="comment">%                 calc_positions(respoi).indices=my_rotamers.indices;</span>
0236 <span class="comment">%                 calc_positions(respoi).NOpos=my_rotamers.NOpos;</span>
0237 <span class="comment">%                 calc_positions(respoi).partition_function=my_rotamers.partition_function;</span>
0238 <span class="comment">%                 calc_positions(respoi).T=my_rotamers.T;</span>
0239 <span class="comment">%                 calc_positions(respoi).potentials=my_rotamers.potentials;</span>
0240 <span class="comment">%                 calc_positions(respoi).rotamers=my_rotamers.rotamers;</span>
0241 <span class="comment">%             end;</span>
0242 <span class="comment">%         end;</span>
0243         
0244         
0245         set(hMain.figure,<span class="string">'Pointer'</span>,<span class="string">'arrow'</span>);
0246 
0247     <span class="keyword">end</span>;
0248     <span class="keyword">if</span> msg.error==5,
0249         <span class="keyword">break</span>;
0250         add_msg_board(<span class="string">'Rotamer computation cancelled.'</span>);
0251         add_msg_board(<span class="string">'Skipping all remaining residues.'</span>);
0252     <span class="keyword">end</span>;
0253 <span class="keyword">end</span>;
0254 
0255 <a name="_sub1" href="#_subfunctions" class="code">function [ecoor,offset]=ecoor_structure(indices,waterflag)</a>
0256 <span class="comment">% returns xyz coordinates for a structure</span>
0257 <span class="comment">% if there are several models, the mean coordinates are returned</span>
0258 <span class="comment">%</span>
0259 <span class="comment">% indices  index vector, length at least 1</span>
0260 
0261 <span class="keyword">global</span> model
0262 
0263 <span class="keyword">if</span> nargin&lt;2,
0264     waterflag=true;
0265 <span class="keyword">end</span>;
0266 
0267 <span class="keyword">if</span> length(indices)&lt;2,
0268     indices=[indices(1),0,1];
0269 <span class="keyword">end</span>;
0270 <span class="keyword">if</span> length(indices)&lt;3,
0271     indices=[indices(1:2) 1];
0272 <span class="keyword">end</span>;
0273 
0274 max_atoms=100000;
0275 ecoor=zeros(max_atoms,4);
0276 
0277 poi=0;
0278 offset=0;
0279 
0280 <span class="keyword">if</span> waterflag,
0281     nc=length(model.structures{indices(1)}); <span class="comment">% number of chains</span>
0282     <span class="keyword">for</span> k=1:nc,
0283         nmod=length(model.structures{indices(1)}(indices(2)).xyz);
0284         <span class="keyword">if</span> k==indices(2) &amp;&amp; indices(3)&lt;=nmod,
0285             chindices=[indices(1),k,indices(3)];
0286         <span class="keyword">else</span>
0287             chindices=[indices(1),k,1];
0288         <span class="keyword">end</span>;
0289         elements=model.structures{chindices(1)}(chindices(2)).isotopes(:,1);
0290         xyz_ch=model.structures{chindices(1)}(chindices(2)).xyz{chindices(3)};
0291         [m,n]=size(xyz_ch);
0292         ecoor(poi+1:poi+m,1)=elements;
0293         ecoor(poi+1:poi+m,2:4)=xyz_ch;
0294         poi=poi+m;
0295         <span class="keyword">if</span> k&lt;indices(2),
0296             offset=offset+m;
0297         <span class="keyword">end</span>;
0298     <span class="keyword">end</span>;
0299     ecoor=ecoor(1:poi,:);
0300 <span class="keyword">else</span>
0301     nc=length(model.structures{indices(1)}); <span class="comment">% number of chains</span>
0302     <span class="keyword">for</span> k=1:nc,
0303         nmod=length(model.structures{indices(1)}(indices(2)).xyz);
0304         <span class="keyword">if</span> k==indices(2) &amp;&amp; indices(3)&lt;=nmod,
0305             chindices=[indices(1),k,indices(3)];
0306         <span class="keyword">else</span>
0307             chindices=[indices(1),k,1];
0308         <span class="keyword">end</span>;
0309         info=model.structures{chindices(1)}(chindices(2)).residues{chindices(3)}.info;
0310         elements=model.structures{chindices(1)}(chindices(2)).isotopes(:,1);
0311         xyz_ch=model.structures{chindices(1)}(chindices(2)).xyz{chindices(3)};
0312         <span class="keyword">for</span> kk=1:length(info),
0313             <span class="keyword">if</span> ~strcmpi(info(kk).name,<span class="string">'HOH'</span>),
0314                 <span class="keyword">for</span> kkk=1:length(info(kk).atom_numbers),
0315                     anum=info(kk).atom_numbers{kkk};
0316                     [ma,na]=size(anum);
0317                     coor=zeros(1,3);
0318                     <span class="keyword">for</span> k4=1:ma,
0319                         poi=poi+1;
0320                         ecoor(poi,1)=elements(anum(k4,1));
0321                         ecoor(poi,2:4)=xyz_ch(anum(k4,1),:);
0322                         <span class="keyword">if</span> k&lt;indices(2),
0323                             offset=offset+1;
0324                         <span class="keyword">end</span>;
0325                     <span class="keyword">end</span>;
0326                 <span class="keyword">end</span>;
0327             <span class="keyword">end</span>;
0328         <span class="keyword">end</span>;
0329     <span class="keyword">end</span>;
0330     ecoor=ecoor(1:poi,:);
0331 <span class="keyword">end</span>;
0332</pre></div>
<hr><address>Generated on Thu 25-Oct-2012 18:03:26 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>