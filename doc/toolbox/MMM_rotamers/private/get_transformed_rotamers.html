<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of get_transformed_rotamers</title>
  <meta name="keywords" content="get_transformed_rotamers">
  <meta name="description" content="function [rotamers_stats,msg]=get_rotamers_transformed(coor,site,calc_opt,rot_lib);">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">toolbox</a> &gt; <a href="../index.html">MMM_rotamers</a> &gt; <a href="index.html">private</a> &gt; get_transformed_rotamers.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for toolbox/MMM_rotamers/private&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>get_transformed_rotamers
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [rotamers_stats,msg]=get_rotamers_transformed(coor,site,calc_opt,rot_lib);</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [rotamers_stats,msg]=get_transformed_rotamers(coor,site,calc_opt,rot_lib) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> function [rotamers_stats,msg]=get_rotamers_transformed(coor,site,calc_opt,rot_lib);</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="mk_pdb_rotamers.html" class="code" title="function calc_positions=mk_pdb_rotamers(allindices,rot_lib,T,no_compute,stat_file,PDB_path,library)">mk_pdb_rotamers</a>	Transforms rotamer coordinates from the native frame in which they are</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [rotamers_stats,msg]=get_transformed_rotamers(coor,site,calc_opt,rot_lib)</a>
0002 
0003 <span class="comment">% function [rotamers_stats,msg]=get_rotamers_transformed(coor,site,calc_opt,rot_lib);</span>
0004 
0005 <span class="comment">% put rotamers from the selected library onto selected mutation position</span>
0006 <span class="comment">% of the protein. No interaction between the rotamers and the protein atoms</span>
0007 <span class="comment">% is computed. Transformed rotamer coordinates are returned.</span>
0008 <span class="comment">% (coordinate transformation step is analogous to the one used in the get_rotamers.m function)</span>
0009 
0010 <span class="comment">% coor          Nx4 array of xyz protein coordinates preceeding with the atom number (carbon=6, nitrogen=7 etc)</span>
0011 <span class="comment">% site          structure, contains information about the requested mutation</span>
0012 <span class="comment">%               position (indices of the protein atoms belonging to the</span>
0013 <span class="comment">%               mutated residue etc); see line 77ff</span>
0014 <span class="comment">% calc_opt      various calculation options (temperature for Boltzman factors,</span>
0015 <span class="comment">%               statistics flag etc); see line 44ff for definitions and defaults</span>
0016 <span class="comment">% rot_lib       structure with choosen rotamer library (atom coordinate for all</span>
0017 <span class="comment">%               rotamers, useful atomic numbers, internal probabilities for each rotamer etc);</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% rotamer_stats</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% msg   structure with fields .error =0: no error</span>
0022 <span class="comment">%       .text clear text error or warning message</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Ye. Polyhach, 2011</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%--------------------------------------------------------------------------</span>
0027 msg.error=0;
0028 msg.text=<span class="string">'Rotamer coordinate transformation successful.'</span>;
0029 <span class="comment">% rotamers_stats.all_potentials=[]; % an empty structure should be returned when an error is encountered</span>
0030 
0031 <span class="comment">% extract information on rotamer library</span>
0032 library=rot_lib.library;
0033 calibration=rot_lib.calibration;
0034 usefull_atoms=rot_lib.usefull_atoms;
0035 midNO=usefull_atoms.midNO;  <span class="comment">% indexes for N and O label atoms</span>
0036 sidech=usefull_atoms.side_chain; <span class="comment">% index for the first side-chain atoms</span>
0037 maxdist=calibration.maxdist; <span class="comment">% max distance rotamer atom from the origin (for the entire library)</span>
0038 
0039 <span class="comment">% extract information on calculation options</span>
0040 
0041 <span class="keyword">if</span> isfield(calc_opt,<span class="string">'T'</span>),
0042     T=calc_opt.T;    <span class="comment">% absolute temperature (K);</span>
0043 <span class="keyword">else</span>
0044     T=calibration.T;
0045 <span class="keyword">end</span>;
0046 
0047 <span class="comment">% if isfield(calc_opt,'ext_potential'),</span>
0048 <span class="comment">%     switch calc_opt.ext_potential</span>
0049 <span class="comment">%         case 'OPLS'</span>
0050 <span class="comment">%             type_poten=1;</span>
0051 <span class="comment">%         case 'charmm27'</span>
0052 <span class="comment">%             type_poten=2;</span>
0053 <span class="comment">%     end;</span>
0054 <span class="comment">% else</span>
0055 <span class="comment">%     type_poten=2; % charmm27 as default</span>
0056 <span class="comment">% end;</span>
0057 
0058 <span class="comment">% if isfield(calc_opt,'forgive'), % forgive factor for minor clashes (reduction factor for effective van-der-Waals radius)</span>
0059 <span class="comment">%     forgive=calc_opt.forgive;</span>
0060 <span class="comment">% else</span>
0061 <span class="comment">%     forgive=0.5; % default forgive factor</span>
0062 <span class="comment">% end;</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% if isfield(calc_opt,'pair_stats'),</span>
0065 <span class="comment">%     pair_stats=calc_opt.pair_stats;    % flag: 0 - no statistics made (default)</span>
0066 <span class="comment">%     %                                       1 - statistics for every pair of atoms is saved (results in a huge file, time consuming)</span>
0067 <span class="comment">% else</span>
0068 <span class="comment">%     pair_stats=0;</span>
0069 <span class="comment">% end;</span>
0070 
0071 <span class="comment">% extract information on mutation site</span>
0072 
0073 index_array=site.res_atoms;
0074 N=site.N;
0075 C=site.C;
0076 Ca=site.CA;
0077 
0078 <span class="comment">%--------------------------------------------------------------------------</span>
0079 n_rot=length(library);  <span class="comment">% get number of rotamers in the library</span>
0080 
0081 NOcoor=zeros(n_rot,5);
0082 mut_coor1=cell(1,n_rot);
0083 labels_own=cell(1,n_rot);
0084 
0085 <span class="comment">% int_pop0=calibration.pop;    % get non-normalized internal populations from the rotamers</span>
0086 <span class="comment">% int_pop0=int_pop0/sum(calibration.pop);   % normalize populations</span>
0087 <span class="comment">% int_pop=int_pop0(1:n_rot); % debugging trick: to be able to reduce n_rot easily</span>
0088 
0089 <span class="comment">% relative_Delta_T=T/calibration.T-1; % relative temeprature difference from calibration</span>
0090 
0091 <span class="comment">% if abs(relative_Delta_T)&gt;temperature_warning,</span>
0092 <span class="comment">%     msg.error=1;</span>
0093 <span class="comment">%     msg.text=sprintf('Target temperature deviates by %2.0f%% from calibration temperature. Reliable limit is %2.0f%%.',100*abs(relative_Delta_T),100*temperature_warning);</span>
0094 <span class="comment">% end</span>
0095 
0096 [m,n]=size(coor);
0097 
0098 <span class="comment">% poten_ext=zeros(1,n_rot);</span>
0099 <span class="comment">% pop_rot=poten_ext;</span>
0100 <span class="comment">% rot_clash=cell(1,n_rot);</span>
0101 
0102 <span class="comment">% comp_status=statusbar('Rotamers: Close to stop.');</span>
0103 
0104 offset=coor(Ca,2:4);    <span class="comment">% origin of frame is the C-alpha atom</span>
0105 <span class="keyword">for</span> kp=1:m,
0106     coor(kp,2:4)=coor(kp,2:4)-offset;
0107 <span class="keyword">end</span>;
0108 x=coor(N,2:4)-coor(Ca,2:4); <span class="comment">% x axis is along C_alpha-N bond</span>
0109 x=x/norm(x);    <span class="comment">% unit vector along x</span>
0110 yp=coor(C,2:4)-coor(Ca,2:4); <span class="comment">% y axis is in the plane spanned by x axis and C-Ca bond</span>
0111 yp=yp/norm(yp);
0112 z=cross_rowvec(x,yp); <span class="comment">% z axis is perpendicular on xy plane</span>
0113 z=z/norm(z);
0114 y=cross_rowvec(z,x); <span class="comment">% real (corrected) y axis</span>
0115 dircos=[x;y;z];
0116 Rp=dircos; <span class="comment">% rotation matrix for conversion to standard frame</span>
0117 
0118 <span class="comment">%-----</span>
0119 <span class="keyword">for</span> k=1:n_rot <span class="comment">% number of rotamers in the library</span>
0120 <span class="comment">%     if mod(k,round(n_rot/10))==0    % just a counter</span>
0121 <span class="comment">%         comp_status=statusbar(k/n_rot,comp_status);</span>
0122 <span class="comment">%         if isempty(comp_status),</span>
0123 <span class="comment">%             msg.error=5;</span>
0124 <span class="comment">%             msg.text='### Warning ### Rotamer analysis stopped.';</span>
0125 <span class="comment">%             return</span>
0126 <span class="comment">%         end;</span>
0127 <span class="comment">%     end;</span>
0128     
0129     lcoor=library(k).ecoor;
0130     new_lcoor=lcoor;
0131     rot_lcoor=lcoor;
0132     own_lcoor=lcoor;
0133     [ml,nl]=size(lcoor);
0134     <span class="keyword">for</span> kr=1:ml <span class="comment">% conversion to standard frame</span>
0135         vec=lcoor(kr,2:4);
0136         newvec=vec*Rp; 
0137         new_lcoor(kr,2:4)=newvec+coor(Ca,2:4);
0138         rot_lcoor(kr,2:4)=newvec+offset;
0139         own_lcoor(kr,2:4)=newvec; <span class="comment">% labels are stored in their own residue frame (Ca is always [0,0,0]);</span>
0140     <span class="keyword">end</span>;
0141     
0142     mut_coor1{k}=rot_lcoor;    <span class="comment">% stores coordinates for running rotamer (k)</span>
0143     labels_own{k}=own_lcoor;
0144     
0145     <span class="comment">% prepare rotamer coordinates for analysis:</span>
0146     <span class="comment">% only side-chain has to be considered during LJenergy calculation</span>
0147     lcoor0=new_lcoor(sidech:ml,:);
0148     lcoor0ind=(sidech:ml);
0149 
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">% % all potentials in one structure:</span>
0153 <span class="comment">% all_pops.pop_rot=pop_rot; % net population: ext*int for each rotamer</span>
0154 <span class="comment">% all_pops.ext_net=poten_ext_sum; % net Boltzmann factor for external potential (partition sum)</span>
0155 <span class="comment">% all_pops.ext_pop=ext_pop; % populations based on the ext potentials only</span>
0156 <span class="comment">% all_pops.partition_function=partition_function; % full partition function</span>
0157 <span class="comment">% statistics for the chosen mutation position is saved as a structure</span>
0158 <span class="comment">% rotamer_stats with the following fields:</span>
0159 <span class="comment">% rotamers_stats.NOall=NOstats_all; % NO-centers and weights for all rotamers in a single matrix;</span>
0160 rotamers_stats.all_rotamers=mut_coor1; <span class="comment">% contains coordinates for all rotated rotamers for current position</span>
0161 <span class="comment">% rotamers_stats.all_potentials=all_pops; % total potential for the mutation position;</span>
0162 rotamers_stats.labels_own=labels_own; <span class="comment">% rotamer coordinates in the local residue frame (Ca is always [0,0,0]);</span>
0163 rotamers_stats.loc_frame_Ca=offset; <span class="comment">% global (protein) coordinates of the local frame origin (Ca alpha of the mutated residue);</span>
0164 <span class="comment">% rotamers_stats.ext_poten_type=type_poten_string; % type of the interatomic potential used</span>
0165 <span class="comment">% if pair_stats==1</span>
0166 <span class="comment">%     rotamers_stats.rot_clash=rot_clash;  % save clash statistics if needed</span>
0167 <span class="comment">% end</span></pre></div>
<hr><address>Generated on Thu 25-Oct-2012 18:03:26 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>